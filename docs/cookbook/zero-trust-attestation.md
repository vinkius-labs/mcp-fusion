# Zero-Trust Attestation

- [Introduction](#introduction)
- [Tool-Level Attestation](#tool-level)
- [Session Attestation](#session)
- [Response Attestation](#response)
- [Audit Trail](#audit)

## Introduction {#introduction}

In enterprise environments, every tool call must be auditable and attributable. Who called what tool, when, with what parameters, and what was the result? **Zero-Trust Attestation** adds cryptographic or structured attestation to every tool execution — ensuring compliance, auditability, and non-repudiation.

## Tool-Level Attestation {#tool-level}

Tag tools with compliance metadata:

```typescript
const f = initFusion<AppContext>();

export const deleteCustomerData = f.mutation('gdpr.delete_customer_data')
  .describe('Permanently delete all data for a customer (GDPR Article 17)')
  .tags('gdpr', 'compliance', 'audit-required')
  .withString('customer_id', 'Customer ID')
  .withString('reason', 'Legal basis for deletion')
  .handle(async (input, ctx) => {
    // Create audit entry first
    await ctx.db.auditLog.create({
      data: {
        action: 'gdpr.delete_customer_data',
        actor: ctx.user.id,
        subject: input.customer_id,
        reason: input.reason,
        timestamp: new Date(),
        sessionId: ctx.sessionId,
      },
    });

    // Execute the deletion
    await ctx.db.customers.delete({ where: { id: input.customer_id } });
    await ctx.db.orders.deleteMany({ where: { customerId: input.customer_id } });
    await ctx.db.documents.deleteMany({ where: { customerId: input.customer_id } });

    return {
      deleted: true,
      customerId: input.customer_id,
      auditRef: `GDPR-${Date.now()}`,
    };
  });
```

## Session Attestation {#session}

Use middleware to attach session attestation to every tool call:

```typescript
const withAttestation = f.middleware(async (ctx) => {
  const session = await verifySession(ctx.token);

  return {
    sessionId: session.id,
    attestation: {
      userId: session.userId,
      ip: session.ip,
      userAgent: session.userAgent,
      mfaVerified: session.mfaVerified,
      grantedAt: session.grantedAt,
      expiresAt: session.expiresAt,
    },
  };
});

// Apply to all tools
const secure = f.group()
  .use(withAuth)
  .use(withAttestation);

export const sensitiveAction = secure.mutation('data.export_pii')
  .describe('Export PII data for authorized review')
  .withString('scope', 'Data scope to export')
  .handle(async (input, ctx) => {
    // ctx.attestation is available for audit logging
    await ctx.db.auditLog.create({
      data: {
        action: 'data.export_pii',
        attestation: ctx.attestation,
        scope: input.scope,
      },
    });

    return ctx.db.piiData.export(input.scope);
  });
```

## Response Attestation {#response}

Include attestation metadata in responses for downstream verification:

```typescript
export const generateReport = f.query('reports.generate')
  .describe('Generate a compliance report')
  .withString('type', 'Report type')
  .handle(async (input, ctx) => {
    const data = await ctx.db.reports.generate(input.type);

    return response(data)
      .llmHint(`Report generated by ${ctx.attestation.userId} at ${new Date().toISOString()}.`)
      .llmHint(`Session MFA verified: ${ctx.attestation.mfaVerified}`)
      .rules([
        'COMPLIANCE: This report contains auditable data. Do not summarize or paraphrase.',
        'Display the full report as provided.',
      ])
      .build();
  });
```

## Audit Trail {#audit}

Use a shared middleware to create a comprehensive audit trail for every tool call:

```typescript
const withAudit = f.middleware(async (ctx) => {
  return {
    audit: async (tool: string, args: Record<string, unknown>, result: string) => {
      await auditService.log({
        tool,
        actor: ctx.user?.id,
        session: ctx.sessionId,
        args,
        result,
        timestamp: new Date(),
      });
    },
  };
});

// Apply to all sensitive tools via a functional group
const audited = f.group().use(withAuth).use(withAttestation).use(withAudit);

export const deleteData = audited.mutation('gdpr.delete')
  .describe('Delete customer data')
  .withString('customer_id', 'Customer ID')
  .handle(async (input, ctx) => {
    await ctx.db.customers.delete({ where: { id: input.customer_id } });
    await ctx.audit('gdpr.delete', input, 'success');
    return { deleted: true, customerId: input.customer_id };
  });
```

> [!IMPORTANT]
> Zero-Trust Attestation is a framework-level pattern. MCP Fusion provides the middleware system — you bring the session management, audit storage, and compliance rules specific to your regulatory requirements (SOC 2, GDPR, HIPAA, etc.).