/**
 * PresenterEmitter — Generates Presenter files (MVA View Layer)
 *
 * For each Prisma model, emits a `{model}Presenter.ts` file containing:
 * 1. A strict Zod **ResponseSchema** — the Egress Firewall
 * 2. A `createPresenter()` binding with systemRules
 *
 * Security rules:
 * - Fields with `@fusion.hide` are physically absent from the schema
 * - Fields with `kind !== 'scalar' && kind !== 'enum'` are filtered (flat-only MVA)
 * - Fields with `@fusion.describe("...")` get `.describe()` calls
 * - Schema uses `.strict()` to reject undeclared fields at runtime
 *
 * @module
 */
import type { DMMFModel, DMMFField, ModelAnnotations } from '../parser/AnnotationParser.js';
import type { GeneratedFile } from '../types.js';
import { toPascalCase } from '../helpers/NamingHelpers.js';

export type { GeneratedFile } from '../types.js';

// ── Type Mapping ─────────────────────────────────────────

/**
 * Map Prisma scalar type to Zod builder expression.
 */
function prismaTypeToZod(field: DMMFField): string {
    const base = mapScalarType(field.type);

    // Apply .describe() if annotation exists (done externally)
    // Apply .optional() if not required
    if (!field.isRequired) {
        return `${base}.optional()`;
    }
    return base;
}

function mapScalarType(prismaType: string): string {
    switch (prismaType) {
        case 'String':   return 'z.string()';
        case 'Int':      return 'z.number().int()';
        case 'Float':    return 'z.number()';
        case 'Decimal':  return 'z.number()';
        case 'Boolean':  return 'z.boolean()';
        case 'DateTime': return 'z.coerce.date()';
        case 'BigInt':   return 'z.bigint()';
        case 'Json':     return 'z.unknown()';
        case 'Bytes':    return 'z.instanceof(Buffer)';
        default:         return 'z.string()'; // Enums fall through to z.string()
    }
}

// ── Public API ───────────────────────────────────────────

/**
 * Generate a Presenter file for a single Prisma model.
 *
 * @param model - Prisma DMMF model
 * @param annotations - Parsed @fusion.* annotations
 * @returns Generated file with path and content
 */
export function emitPresenter(model: DMMFModel, annotations: ModelAnnotations): GeneratedFile {
    const name = toPascalCase(model.name);
    const lines: string[] = [];

    // ── Imports ───────────────────────────────────────────
    lines.push(`/**`);
    lines.push(` * ${name}Presenter — Generated by vinkius-prisma-gen`);
    lines.push(` *`);
    lines.push(` * Egress Firewall: fields marked @fusion.hide are physically absent.`);
    lines.push(` * This file is auto-generated. Manual edits will be overwritten.`);
    lines.push(` *`);
    lines.push(` * @generated`);
    lines.push(` */`);
    lines.push(`import { z } from 'zod';`);
    lines.push(`import { createPresenter } from '@vinkius-core/mcp-fusion';`);
    lines.push(``);

    // ── Response Schema ──────────────────────────────────
    lines.push(`// ── Response Schema (Egress Firewall) ────────────────────`);
    lines.push(``);
    lines.push(`export const ${name}ResponseSchema = z.object({`);

    // Filter: scalar/enum only (flat-only MVA — no relations)
    const scalarFields = model.fields.filter(
        f => f.kind === 'scalar' || f.kind === 'enum',
    );

    for (const field of scalarFields) {
        const ann = annotations.fields.get(field.name);

        // @fusion.hide — physically exclude from Response
        if (ann?.hidden) continue;

        let zodExpr = prismaTypeToZod(field);

        // @fusion.describe — inject .describe() for LLM semantics
        if (ann?.description) {
            const escaped = ann.description.replace(/'/g, "\\'");
            // Insert .describe() before .optional() if present
            if (zodExpr.endsWith('.optional()')) {
                const base = zodExpr.slice(0, -'.optional()'.length);
                zodExpr = `${base}.describe('${escaped}').optional()`;
            } else {
                zodExpr = `${zodExpr}.describe('${escaped}')`;
            }
        }

        lines.push(`    ${field.name}: ${zodExpr},`);
    }

    lines.push(`}).strict();`);
    lines.push(``);

    // ── Presenter ────────────────────────────────────────
    lines.push(`// ── Presenter ────────────────────────────────────────────`);
    lines.push(``);
    lines.push(`export const ${name}Presenter = createPresenter('${name}')`);
    lines.push(`    .schema(${name}ResponseSchema)`);
    lines.push(`    .systemRules(['Data originates from the database via Prisma ORM.']);`);
    lines.push(``);

    return {
        path: `${model.name.charAt(0).toLowerCase() + model.name.slice(1)}Presenter.ts`,
        content: lines.join('\n'),
    };
}
