/**
 * ToolEmitter — Generates Tool files (MVA Agent Layer)
 *
 * For each Prisma model, emits a `{model}Tools.ts` file containing:
 * 1. `PrismaFusionContext` type — shift-left TS safety for ctx.prisma + ctx.tenantId
 * 2. `CreateSchema` — input params (no @id/@default, no @fusion.tenantKey, YES @fusion.hide)
 * 3. `UpdateSchema` — all Create fields as .optional()
 * 4. 5 CRUD actions: find_many, find_unique, create, update, delete
 *
 * Security rules:
 * - Schema asymmetry: ResponseSchema ≠ CreateSchema ≠ UpdateSchema
 * - @fusion.tenantKey → injected into WHERE/data of every query from ctx
 * - @id @default fields → excluded from CreateSchema (server/DB generates)
 * - find_many → forced pagination: take max 50, skip default 0
 * - delete → destructive: true
 * - find_many/find_unique → readOnly: true
 * - Relations filtered (scalar/enum only)
 *
 * @module
 */
import type { DMMFModel, DMMFField, ModelAnnotations } from '../parser/AnnotationParser.js';
import type { GeneratedFile } from '../types.js';
import { toPascalCase, toSnakeCase } from '../helpers/NamingHelpers.js';

// ── Type Mapping ─────────────────────────────────────────

function mapScalarType(prismaType: string): string {
    switch (prismaType) {
        case 'String':   return 'z.string()';
        case 'Int':      return 'z.number().int()';
        case 'Float':    return 'z.number()';
        case 'Decimal':  return 'z.number()';
        case 'Boolean':  return 'z.boolean()';
        case 'DateTime': return 'z.coerce.date()';
        case 'BigInt':   return 'z.bigint()';
        case 'Json':     return 'z.unknown()';
        case 'Bytes':    return 'z.instanceof(Buffer)';
        default:         return 'z.string()';
    }
}

// ── Field Classification ─────────────────────────────────

/**
 * Determine if a field should be excluded from CreateSchema.
 * Excludes: @id with @default, @fusion.tenantKey, auto-generated timestamps.
 */
function isAutoGenerated(field: DMMFField, annotations: ModelAnnotations): boolean {
    const ann = annotations.fields.get(field.name);

    // @id with default value (uuid, autoincrement, cuid, etc.)
    if (field.isId && field.hasDefaultValue) return true;

    // @fusion.tenantKey — injected from ctx, not from LLM
    if (ann?.tenantKey) return true;

    // Common auto-generated timestamp fields
    if (field.hasDefaultValue && (field.name === 'createdAt' || field.name === 'updatedAt')) {
        return true;
    }

    return false;
}

// ── Public API ───────────────────────────────────────────

/**
 * Generate a Tool file for a single Prisma model.
 *
 * @param model - Prisma DMMF model
 * @param annotations - Parsed @fusion.* annotations
 * @returns Generated file with path and content
 */
export function emitTool(model: DMMFModel, annotations: ModelAnnotations): GeneratedFile {
    const name = toPascalCase(model.name);
    const snakeName = toSnakeCase(model.name);
    const prismaModel = model.name.charAt(0).toLowerCase() + model.name.slice(1);
    const lines: string[] = [];

    // ── Header ───────────────────────────────────────────
    lines.push(`/**`);
    lines.push(` * ${name}Tools — Generated by vinkius-prisma-gen`);
    lines.push(` *`);
    lines.push(` * CRUD tool with tenant isolation and OOM protection.`);
    lines.push(` * This file is auto-generated. Manual edits will be overwritten.`);
    lines.push(` *`);
    lines.push(` * @generated`);
    lines.push(` */`);
    lines.push(`import { z } from 'zod';`);
    lines.push(`import { defineTool } from '@vinkius-core/mcp-fusion';`);
    lines.push(`import { ${name}Presenter } from './${prismaModel}Presenter.js';`);
    lines.push(``);

    // ── Context Type (Shift-Left Security) ───────────────
    emitContextType(lines, annotations);

    // ── Scalar fields ────────────────────────────────────
    const scalarFields = model.fields.filter(
        f => f.kind === 'scalar' || f.kind === 'enum',
    );

    // Fields for CreateSchema: exclude auto-generated, include @fusion.hide
    const createFields = scalarFields.filter(f => !isAutoGenerated(f, annotations));

    // Find the @id field for find_unique/update/delete
    const idField = scalarFields.find(f => f.isId);
    const idName = idField?.name ?? 'id';
    const idZod = idField ? mapScalarType(idField.type) : 'z.string()';

    // Filterable fields for find_many (string fields, excluding hidden and tenant)
    const filterableFields = scalarFields.filter(f => {
        const ann = annotations.fields.get(f.name);
        return f.type === 'String' && !ann?.hidden && !ann?.tenantKey && !f.isId;
    });

    // ── Tool Definition ──────────────────────────────────
    lines.push(`export const ${prismaModel}Tools = defineTool<PrismaFusionContext>('db_${snakeName}', {`);
    lines.push(`    actions: {`);

    // ── find_many ─────────────────────────────────────────
    emitFindMany(lines, model, annotations, prismaModel, filterableFields);

    // ── find_unique ───────────────────────────────────────
    emitFindUnique(lines, annotations, prismaModel, idName, idZod);

    // ── create ────────────────────────────────────────────
    emitCreate(lines, annotations, prismaModel, createFields);

    // ── update ────────────────────────────────────────────
    emitUpdate(lines, annotations, prismaModel, idName, idZod, createFields);

    // ── delete ────────────────────────────────────────────
    emitDelete(lines, annotations, prismaModel, idName, idZod);

    lines.push(`    },`);
    lines.push(`});`);
    lines.push(``);

    return {
        path: `${prismaModel}Tools.ts`,
        content: lines.join('\n'),
    };
}

// ── Context Type Emitter ─────────────────────────────────

function emitContextType(lines: string[], annotations: ModelAnnotations): void {
    lines.push(`// ── Context Contract (Shift-Left Security) ──────────────`);
    lines.push(`//`);
    lines.push(`// If the developer forgets to provide these in contextFactory,`);
    lines.push(`// TypeScript compilation fails — not runtime.`);
    lines.push(``);
    lines.push(`export interface PrismaFusionContext {`);
    lines.push(`    readonly prisma: { [model: string]: any };`);

    if (annotations.tenantKeyField) {
        lines.push(`    /** Tenant isolation key — injected into every query WHERE clause */`);
        lines.push(`    readonly ${annotations.tenantKeyField}: string;`);
    }

    lines.push(`}`);
    lines.push(``);
}

// ── Action Emitters ──────────────────────────────────────

function emitFindMany(
    lines: string[],
    model: DMMFModel,
    annotations: ModelAnnotations,
    prismaModel: string,
    filterableFields: DMMFField[],
): void {
    lines.push(`        find_many: {`);
    lines.push(`            readOnly: true,`);
    lines.push(`            description: 'List ${model.name} records with pagination',`);
    lines.push(`            returns: ${toPascalCase(model.name)}Presenter,`);
    lines.push(`            params: z.object({`);

    // Filterable string fields → contains filter
    for (const f of filterableFields) {
        const ann = annotations.fields.get(f.name);
        const desc = ann?.description ? `.describe('Filter by ${f.name}')` : '';
        lines.push(`                ${f.name}_contains: z.string()${desc}.optional(),`);
    }

    // Pagination — OOM protection
    lines.push(`                take: z.number().int().min(1).max(50).default(20).describe('Max rows per page (capped at 50)'),`);
    lines.push(`                skip: z.number().int().min(0).default(0).describe('Offset for pagination'),`);
    lines.push(`            }),`);
    lines.push(`            handler: async (ctx, args) => {`);

    // Build WHERE clause
    lines.push(`                const where: Record<string, unknown> = {};`);

    // Tenant isolation
    if (annotations.tenantKeyField) {
        lines.push(`                where['${annotations.tenantKeyField}'] = ctx.${annotations.tenantKeyField};`);
    }

    // Filters
    for (const f of filterableFields) {
        lines.push(`                if (args.${f.name}_contains !== undefined) {`);
        lines.push(`                    where['${f.name}'] = { contains: args.${f.name}_contains };`);
        lines.push(`                }`);
    }

    lines.push(`                return await ctx.prisma.${prismaModel}.findMany({`);
    lines.push(`                    where,`);
    lines.push(`                    take: args.take,`);
    lines.push(`                    skip: args.skip,`);
    lines.push(`                });`);
    lines.push(`            },`);
    lines.push(`        },`);
}

function emitFindUnique(
    lines: string[],
    annotations: ModelAnnotations,
    prismaModel: string,
    idName: string,
    idZod: string,
): void {
    lines.push(`        find_unique: {`);
    lines.push(`            readOnly: true,`);
    lines.push(`            description: 'Get a single record by ID',`);
    lines.push(`            returns: ${toPascalCase(prismaModel)}Presenter,`);
    lines.push(`            params: z.object({`);
    lines.push(`                ${idName}: ${idZod},`);
    lines.push(`            }),`);
    lines.push(`            handler: async (ctx, args) => {`);

    // WHERE with tenant isolation
    if (annotations.tenantKeyField) {
        lines.push(`                return await ctx.prisma.${prismaModel}.findUniqueOrThrow({`);
        lines.push(`                    where: { ${idName}: args.${idName}, ${annotations.tenantKeyField}: ctx.${annotations.tenantKeyField} },`);
        lines.push(`                });`);
    } else {
        lines.push(`                return await ctx.prisma.${prismaModel}.findUniqueOrThrow({`);
        lines.push(`                    where: { ${idName}: args.${idName} },`);
        lines.push(`                });`);
    }

    lines.push(`            },`);
    lines.push(`        },`);
}

function emitCreate(
    lines: string[],
    annotations: ModelAnnotations,
    prismaModel: string,
    createFields: DMMFField[],
): void {
    lines.push(`        create: {`);
    lines.push(`            description: 'Create a new record',`);
    lines.push(`            returns: ${toPascalCase(prismaModel)}Presenter,`);
    lines.push(`            params: z.object({`);

    for (const field of createFields) {
        const ann = annotations.fields.get(field.name);
        let zodExpr = mapScalarType(field.type);

        if (ann?.description) {
            zodExpr = `${zodExpr}.describe('${ann.description.replace(/'/g, "\\'")}')`;
        }

        // Optional fields stay optional in create
        if (!field.isRequired || field.hasDefaultValue) {
            zodExpr = `${zodExpr}.optional()`;
        }

        lines.push(`                ${field.name}: ${zodExpr},`);
    }

    lines.push(`            }),`);
    lines.push(`            handler: async (ctx, args) => {`);

    if (annotations.tenantKeyField) {
        lines.push(`                return await ctx.prisma.${prismaModel}.create({`);
        lines.push(`                    data: { ...args, ${annotations.tenantKeyField}: ctx.${annotations.tenantKeyField} },`);
        lines.push(`                });`);
    } else {
        lines.push(`                return await ctx.prisma.${prismaModel}.create({`);
        lines.push(`                    data: args,`);
        lines.push(`                });`);
    }

    lines.push(`            },`);
    lines.push(`        },`);
}

function emitUpdate(
    lines: string[],
    annotations: ModelAnnotations,
    prismaModel: string,
    idName: string,
    idZod: string,
    createFields: DMMFField[],
): void {
    lines.push(`        update: {`);
    lines.push(`            description: 'Update an existing record',`);
    lines.push(`            returns: ${toPascalCase(prismaModel)}Presenter,`);
    lines.push(`            params: z.object({`);
    lines.push(`                ${idName}: ${idZod},`);

    // All create fields as .optional() for partial update
    for (const field of createFields) {
        if (field.name === idName) continue; // Skip ID, already added

        const ann = annotations.fields.get(field.name);
        let zodExpr = mapScalarType(field.type);

        if (ann?.description) {
            zodExpr = `${zodExpr}.describe('${ann.description.replace(/'/g, "\\'")}')`;
        }

        lines.push(`                ${field.name}: ${zodExpr}.optional(),`);
    }

    lines.push(`            }),`);
    lines.push(`            handler: async (ctx, args) => {`);
    lines.push(`                const { ${idName}, ...data } = args;`);

    if (annotations.tenantKeyField) {
        lines.push(`                return await ctx.prisma.${prismaModel}.update({`);
        lines.push(`                    where: { ${idName}, ${annotations.tenantKeyField}: ctx.${annotations.tenantKeyField} },`);
        lines.push(`                    data,`);
        lines.push(`                });`);
    } else {
        lines.push(`                return await ctx.prisma.${prismaModel}.update({`);
        lines.push(`                    where: { ${idName} },`);
        lines.push(`                    data,`);
        lines.push(`                });`);
    }

    lines.push(`            },`);
    lines.push(`        },`);
}

function emitDelete(
    lines: string[],
    annotations: ModelAnnotations,
    prismaModel: string,
    idName: string,
    idZod: string,
): void {
    lines.push(`        delete: {`);
    lines.push(`            destructive: true,`);
    lines.push(`            description: 'Delete a record by ID',`);
    lines.push(`            params: z.object({`);
    lines.push(`                ${idName}: ${idZod},`);
    lines.push(`            }),`);
    lines.push(`            handler: async (ctx, args) => {`);

    if (annotations.tenantKeyField) {
        lines.push(`                await ctx.prisma.${prismaModel}.delete({`);
        lines.push(`                    where: { ${idName}: args.${idName}, ${annotations.tenantKeyField}: ctx.${annotations.tenantKeyField} },`);
        lines.push(`                });`);
    } else {
        lines.push(`                await ctx.prisma.${prismaModel}.delete({`);
        lines.push(`                    where: { ${idName}: args.${idName} },`);
        lines.push(`                });`);
    }

    lines.push(`                return { deleted: true };`);
    lines.push(`            },`);
    lines.push(`        },`);
}
