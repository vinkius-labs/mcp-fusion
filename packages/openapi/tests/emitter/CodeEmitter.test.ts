import { describe, it, expect } from 'vitest';
import { emitFiles } from '../../src/emitter/CodeEmitter.js';
import { mergeConfig, DEFAULT_CONFIG } from '../../src/config/GeneratorConfig.js';
import type { ApiSpec, ApiGroup } from '../../src/parser/types.js';

// ── Helpers ──

function makeSpec(groups: ApiGroup[]): ApiSpec {
    return { title: 'Test API', version: '1.0.0', servers: [], groups };
}

const PET_GROUP: ApiGroup = {
    tag: 'pet',
    description: 'Everything about your pets',
    actions: [
        {
            name: 'get_pet_by_id',
            operationId: 'getPetById',
            method: 'get',
            path: '/pet/{petId}',
            summary: 'Find pet by ID',
            params: [
                { name: 'petId', source: 'path', required: true, schema: { type: 'integer' }, description: 'ID of pet to return' },
            ],
            responses: [
                {
                    statusCode: '200',
                    description: 'successful operation',
                    schema: {
                        type: 'object',
                        properties: {
                            id: { type: 'integer' },
                            name: { type: 'string' },
                            status: { type: 'string', enum: ['available', 'pending', 'sold'] },
                        },
                        required: ['id', 'name'],
                    },
                },
            ],
            tags: ['pet'],
        },
        {
            name: 'delete_pet',
            operationId: 'deletePet',
            method: 'delete',
            path: '/pet/{petId}',
            summary: 'Delete a pet',
            params: [
                { name: 'petId', source: 'path', required: true, schema: { type: 'integer' } },
            ],
            responses: [{ statusCode: '200', description: 'OK' }],
            tags: ['pet'],
        },
    ],
};

// ============================================================================
// CodeEmitter Tests (MVA Convention)
// ============================================================================

describe('CodeEmitter', () => {
    // ── File Generation (MVA Structure) ──

    describe('File Generation (MVA Convention)', () => {
        it('should generate Schema + Presenter + Tool + index + server files', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const paths = files.map(f => f.path);
            expect(paths).toContain('models/pet.schema.ts');
            expect(paths).toContain('views/pet.presenter.ts');
            expect(paths).toContain('agents/pet.tool.ts');
            expect(paths).toContain('index.ts');
            expect(paths).toContain('server.ts');
        });

        it('should generate 5 files for a single tag (schema + presenter + tool + index + server)', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            expect(files).toHaveLength(5);
        });

        it('should generate auto-generated header comment', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            for (const file of files) {
                expect(file.content).toContain('Auto-generated by @mcp-fusion/openapi-gen');
            }
        });

        it('should annotate MVA layer in schema file header', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const schema = files.find(f => f.path === 'models/pet.schema.ts')!;
            expect(schema.content).toContain('MVA Layer: Model');
        });

        it('should annotate MVA layer in presenter file header', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const presenter = files.find(f => f.path === 'views/pet.presenter.ts')!;
            expect(presenter.content).toContain('MVA Layer: View');
        });

        it('should annotate MVA layer in tool file header', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tool = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tool.content).toContain('MCP Tool: delivery layer');
        });
    });

    // ── Schema File (Model Layer) ──

    describe('Schema File (Model Layer)', () => {
        it('should import zod', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const schema = files.find(f => f.path === 'models/pet.schema.ts')!;
            expect(schema.content).toContain("import { z } from 'zod'");
        });

        it('should export response schema', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const schema = files.find(f => f.path === 'models/pet.schema.ts')!;
            expect(schema.content).toContain('export const PetResponseSchema');
        });

        it('should NOT import createPresenter (separation of concerns)', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const schema = files.find(f => f.path === 'models/pet.schema.ts')!;
            expect(schema.content).not.toContain('createPresenter');
        });
    });

    // ── Presenter File (View Layer) ──

    describe('Presenter File (View Layer)', () => {
        it('should import createPresenter', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const presenter = files.find(f => f.path === 'views/pet.presenter.ts')!;
            expect(presenter.content).toContain("import { createPresenter } from '@vinkius-core/mcp-fusion'");
        });

        it('should import schema from models/ directory', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const presenter = files.find(f => f.path === 'views/pet.presenter.ts')!;
            expect(presenter.content).toContain("from '../models/pet.schema.js'");
        });

        it('should export Presenter with schema binding', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const presenter = files.find(f => f.path === 'views/pet.presenter.ts')!;
            expect(presenter.content).toContain('export const PetPresenter');
            expect(presenter.content).toContain('.schema(PetResponseSchema)');
        });
    });

    // ── Tool File (MCP Delivery) ──

    describe('Tool File (MCP Delivery)', () => {
        it('should import defineTool + success + error', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain("import { defineTool, success, error } from '@vinkius-core/mcp-fusion'");
        });

        it('should import Presenter from views/ directory', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain("from '../views/pet.presenter.js'");
        });

        it('should declare defineTool with tag name', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain("defineTool<ApiContext>('pet'");
        });

        it('should emit action names', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain('get_pet_by_id:');
            expect(tools.content).toContain('delete_pet:');
        });

        it('should emit Zod input params with coercion for path params', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain('z.coerce.number().int()');
        });

        it('should emit fetch handler with URL interpolation', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain('fetch(');
            expect(tools.content).toContain('${args.petId}');
        });
    });

    // ── Feature: Annotations ──

    describe('Feature: Annotations', () => {
        it('should emit readOnly for GET actions (annotations=true)', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain('readOnly: true');
        });

        it('should emit destructive for DELETE actions (annotations=true)', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain('destructive: true');
        });

        it('should NOT emit annotations when disabled', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ features: { annotations: false } });
            const files = emitFiles(spec, cfg);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).not.toContain('readOnly: true');
            expect(tools.content).not.toContain('destructive: true');
        });
    });

    // ── Feature: Tags ──

    describe('Feature: Tags', () => {
        it('should emit tags array when enabled', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain("tags: ['pet']");
        });

        it('should NOT emit tags when disabled', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ features: { tags: false } });
            const files = emitFiles(spec, cfg);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).not.toContain("tags:");
        });
    });

    // ── Feature: Presenters ──

    describe('Feature: Presenters', () => {
        it('should NOT generate Schema or Presenter files when disabled', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ features: { presenters: false } });
            const files = emitFiles(spec, cfg);
            expect(files.find(f => f.path === 'models/pet.schema.ts')).toBeUndefined();
            expect(files.find(f => f.path === 'views/pet.presenter.ts')).toBeUndefined();
        });

        it('should bind returns: Presenter when enabled', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain('returns: PetPresenter');
        });

        it('should NOT bind Presenter when disabled', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ features: { presenters: false } });
            const files = emitFiles(spec, cfg);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).not.toContain('returns:');
        });
    });

    // ── Feature: toonDescription ──

    describe('Feature: toonDescription', () => {
        it('should NOT emit toonDescription by default', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).not.toContain('toonDescription');
        });

        it('should emit toonDescription when enabled', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ features: { toonDescription: true } });
            const files = emitFiles(spec, cfg);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain('toonDescription: true');
        });
    });

    // ── Feature: Server File ──

    describe('Feature: Server File', () => {
        it('should generate server.ts with MCP Server bootstrap', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const server = files.find(f => f.path === 'server.ts')!;
            expect(server).toBeDefined();
            expect(server.content).toContain("import { Server } from '@modelcontextprotocol/sdk/server/index.js'");
            expect(server.content).toContain("import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'");
            expect(server.content).toContain('registry.attachToServer(server, {');
        });

        it('should include server name and version from config', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ server: { name: 'pet-api-mcp', version: '2.0.0' } });
            const files = emitFiles(spec, cfg);
            const server = files.find(f => f.path === 'server.ts')!;
            expect(server.content).toContain("'pet-api-mcp'");
            expect(server.content).toContain("'2.0.0'");
        });

        it('should include env var context factory', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const server = files.find(f => f.path === 'server.ts')!;
            expect(server.content).toContain("process.env['API_BASE_URL']");
            expect(server.content).toContain("process.env['API_KEY']");
        });

        it('should NOT generate server.ts when disabled', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ features: { serverFile: false } });
            const files = emitFiles(spec, cfg);
            expect(files.find(f => f.path === 'server.ts')).toBeUndefined();
        });
    });

    // ── Barrel Index ──

    describe('Barrel Index', () => {
        it('should import tools from agents/ directory', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const index = files.find(f => f.path === 'index.ts')!;
            expect(index.content).toContain("from './agents/pet.tool.js'");
        });

        it('should import and re-export all tools', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const index = files.find(f => f.path === 'index.ts')!;
            expect(index.content).toContain("import { petTools }");
            expect(index.content).toContain("export { petTools }");
        });

        it('should re-export schemas and presenters', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const index = files.find(f => f.path === 'index.ts')!;
            expect(index.content).toContain("from './models/pet.schema.js'");
            expect(index.content).toContain("from './views/pet.presenter.js'");
        });

        it('should create ToolRegistry and registerAll', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const index = files.find(f => f.path === 'index.ts')!;
            expect(index.content).toContain("import { ToolRegistry } from '@vinkius-core/mcp-fusion'");
            expect(index.content).toContain('new ToolRegistry');
            expect(index.content).toContain('registry.registerAll(petTools)');
        });
    });

    // ── Tag Filtering ──

    describe('Tag Filtering', () => {
        const STORE_GROUP: ApiGroup = {
            tag: 'store',
            actions: [{
                name: 'get_inventory', method: 'get', path: '/store/inventory',
                params: [], responses: [], tags: ['store'],
            }],
        };

        it('should filter groups by includeTags', () => {
            const spec = makeSpec([PET_GROUP, STORE_GROUP]);
            const cfg = mergeConfig({ includeTags: ['pet'] });
            const files = emitFiles(spec, cfg);
            expect(files.find(f => f.path === 'agents/pet.tool.ts')).toBeDefined();
            expect(files.find(f => f.path === 'agents/store.tool.ts')).toBeUndefined();
        });

        it('should filter groups by excludeTags', () => {
            const spec = makeSpec([PET_GROUP, STORE_GROUP]);
            const cfg = mergeConfig({ excludeTags: ['store'] });
            const files = emitFiles(spec, cfg);
            expect(files.find(f => f.path === 'agents/pet.tool.ts')).toBeDefined();
            expect(files.find(f => f.path === 'agents/store.tool.ts')).toBeUndefined();
        });
    });

    // ── Custom Context ──

    describe('Custom Context', () => {
        it('should use custom context type from config', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ context: { import: '../types.js#AppCtx' } });
            const files = emitFiles(spec, cfg);
            const tools = files.find(f => f.path === 'agents/pet.tool.ts')!;
            expect(tools.content).toContain("import type { AppCtx }");
            expect(tools.content).toContain("defineTool<AppCtx>");
        });
    });

    // ── Tool Exposition ──

    describe('Tool Exposition', () => {
        it('should default to flat toolExposition in server.ts', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const server = files.find(f => f.path === 'server.ts')!;
            expect(server.content).toContain("toolExposition: 'flat'");
        });

        it('should emit grouped toolExposition when configured', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ server: { toolExposition: 'grouped' } });
            const files = emitFiles(spec, cfg);
            const server = files.find(f => f.path === 'server.ts')!;
            expect(server.content).toContain("toolExposition: 'grouped'");
        });

        it('should NOT emit actionSeparator when using default underscore', () => {
            const spec = makeSpec([PET_GROUP]);
            const files = emitFiles(spec);
            const server = files.find(f => f.path === 'server.ts')!;
            expect(server.content).not.toContain('actionSeparator');
        });

        it('should emit actionSeparator when non-default value', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ server: { actionSeparator: '.' } });
            const files = emitFiles(spec, cfg);
            const server = files.find(f => f.path === 'server.ts')!;
            expect(server.content).toContain("actionSeparator: '.'");
        });

        it('should emit both grouped and custom separator together', () => {
            const spec = makeSpec([PET_GROUP]);
            const cfg = mergeConfig({ server: { toolExposition: 'grouped', actionSeparator: '-' } });
            const files = emitFiles(spec, cfg);
            const server = files.find(f => f.path === 'server.ts')!;
            expect(server.content).toContain("toolExposition: 'grouped'");
            expect(server.content).toContain("actionSeparator: '-'");
        });
    });
});
