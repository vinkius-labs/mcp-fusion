/**
 * CodeEmitter — Full MCP Server Generator (MVA Convention)
 *
 * Generates a **complete, ready-to-run MCP Server** following the MVA directory convention:
 *
 *   models/{tag}.schema.ts       — M: Zod response schemas (data boundary)
 *   views/{tag}.presenter.ts     — V: createPresenter() scaffolds (perception layer)
 *   agents/{tag}.tool.ts         — A: defineTool() with all MCP Fusion features
 *   index.ts                      — Barrel export + ToolRegistry + registerAll()
 *   server.ts                     — Complete MCP Server with attachToServer()
 *
 * Every feature is controlled by {@link GeneratorConfig}.
 *
 * @module
 */
import type { ApiSpec, ApiGroup, ApiAction, SchemaNode } from '../parser/types.js';
import { compileInputSchema, compileResponseSchema } from '../schema/ZodCompiler.js';
import { inferAnnotations } from '../mapper/EndpointMapper.js';
import {
    toPascalCase, toCamelCase, escapeTs,
    buildUrlTemplate, schemaFileName, presenterFileName, toolFileName,
} from './TemplateHelpers.js';
import { type GeneratorConfig, DEFAULT_CONFIG } from '../config/GeneratorConfig.js';

// ── Public Types ─────────────────────────────────────────

/** A generated file with its path and content */
export interface GeneratedFile {
    readonly path: string;
    readonly content: string;
}

/** @deprecated Use GeneratorConfig instead */
export interface EmitterConfig {
    readonly baseUrl?: string;
    readonly contextImport?: string;
}

// ── Public API ───────────────────────────────────────────

/**
 * Generate all files from a mapped OpenAPI spec.
 *
 * Follows the MVA directory convention:
 *   models/  → Zod schemas (Model layer)
 *   views/   → createPresenter (View layer)
 *   agents/  → defineTool (Agent layer)
 *
 * @param spec - Mapped ApiSpec (actions must have resolved names)
 * @param config - Full generator configuration or legacy EmitterConfig
 * @returns Array of generated files
 */
export function emitFiles(spec: ApiSpec, config: GeneratorConfig | EmitterConfig = DEFAULT_CONFIG): GeneratedFile[] {
    const cfg = normalizeConfig(config);
    const files: GeneratedFile[] = [];

    for (const group of spec.groups) {
        // Tag filtering
        if (shouldSkipGroup(group, cfg)) continue;

        // Schema file (Model layer)
        if (cfg.features.presenters) {
            files.push(emitSchemaFile(group, cfg));
        }

        // Presenter file (View layer)
        if (cfg.features.presenters) {
            files.push(emitPresenterFile(group, cfg));
        }

        // Tool file (Agent layer)
        files.push(emitToolFile(group, cfg));
    }

    // Barrel index
    files.push(emitBarrelFile(spec, cfg));

    // Complete MCP Server file
    if (cfg.features.serverFile) {
        files.push(emitServerFile(spec, cfg));
    }

    return files;
}

// ── Schema File (Model Layer) ────────────────────────────

function emitSchemaFile(group: ApiGroup, cfg: GeneratorConfig): GeneratedFile {
    const tag = group.tag;
    const pascal = toPascalCase(tag);
    const lines: string[] = [];

    // Header
    lines.push(`// Auto-generated by @mcp-fusion/openapi-gen`);
    lines.push(`// Source tag: "${tag}"`);
    lines.push(`// MVA Layer: Model (data boundary)`);
    lines.push(`// DO NOT EDIT — re-run the generator to update.`);
    lines.push(``);
    lines.push(`import { z } from 'zod';`);
    lines.push(``);

    // Collect response schemas
    const schemas = collectResponseSchemas(group);

    if (schemas.size === 0) {
        // Emit a placeholder schema
        lines.push(`// ── Schemas ─────────────────────────────────────────────`);
        lines.push(``);
        lines.push(`export const ${pascal}ResponseSchema = z.object({`);
        lines.push(`    // TODO: Define response schema for the ${pascal} entity`);
        lines.push(`});`);
    } else {
        lines.push(`// ── Response Schemas ────────────────────────────────────`);
        lines.push(``);

        for (const [schemaName, schemaNode] of schemas) {
            const zodCode = compileResponseSchema(schemaNode);
            lines.push(`export const ${schemaName}Schema = ${zodCode};`);
            lines.push(``);
        }
    }

    return {
        path: schemaFileName(tag),
        content: lines.join('\n') + '\n',
    };
}

// ── Presenter File (View Layer) ──────────────────────────

function emitPresenterFile(group: ApiGroup, cfg: GeneratorConfig): GeneratedFile {
    const tag = group.tag;
    const pascal = toPascalCase(tag);
    const lines: string[] = [];

    // Header
    lines.push(`// Auto-generated by @mcp-fusion/openapi-gen`);
    lines.push(`// Source tag: "${tag}"`);
    lines.push(`// MVA Layer: View (perception layer)`);
    lines.push(`// DO NOT EDIT — re-run the generator to update.`);
    lines.push(``);
    lines.push(`import { createPresenter } from '@vinkius-core/mcp-fusion';`);

    // Import schemas from model layer
    const schemas = collectResponseSchemas(group);
    const schemaImports: string[] = [];

    if (schemas.size === 0) {
        schemaImports.push(`${pascal}ResponseSchema`);
    } else {
        for (const [schemaName] of schemas) {
            schemaImports.push(`${schemaName}Schema`);
        }
    }

    lines.push(`import { ${schemaImports.join(', ')} } from '${schemaImportPath(tag)}';`);
    lines.push(``);

    // Presenters
    lines.push(`// ── Presenters ──────────────────────────────────────────`);
    lines.push(``);

    if (schemas.size === 0) {
        lines.push(`export const ${pascal}Presenter = createPresenter('${escapeTs(pascal)}')`);
        lines.push(`    .schema(${pascal}ResponseSchema)`);
        lines.push(`    .systemRules([`);
        lines.push(`        // TODO: Add LLM business rules for the ${pascal} entity`);
        lines.push(`    ]);`);
    } else {
        for (const [schemaName] of schemas) {
            const presenterName = schemaName.replace(/Response$/, '') + 'Presenter';
            lines.push(`export const ${presenterName} = createPresenter('${escapeTs(schemaName.replace(/Response$/, ''))}')`);
            lines.push(`    .schema(${schemaName}Schema)`);
            lines.push(`    .systemRules([`);

            if (cfg.features.descriptions) {
                lines.push(`        'Data originates from the ${pascal} API.',`);
            }

            lines.push(`    ]);`);
            lines.push(``);
        }
    }

    return {
        path: presenterFileName(tag),
        content: lines.join('\n') + '\n',
    };
}

// ── Tool File (MCP Delivery) ─────────────────────────────

function emitToolFile(group: ApiGroup, cfg: GeneratorConfig): GeneratedFile {
    const tag = group.tag;
    const pascal = toPascalCase(tag);
    const camel = toCamelCase(tag);
    const lines: string[] = [];

    const contextType = resolveContextType(cfg);

    // Header
    lines.push(`// Auto-generated by @mcp-fusion/openapi-gen`);
    lines.push(`// Source tag: "${tag}"`);
    lines.push(`// MCP Tool: delivery layer for the Agent`);
    lines.push(`// DO NOT EDIT — re-run the generator to update.`);
    lines.push(``);
    lines.push(`import { defineTool, success, error } from '@vinkius-core/mcp-fusion';`);
    lines.push(`import { z } from 'zod';`);

    // Import Presenters from the View layer
    const schemas = cfg.features.presenters ? collectResponseSchemas(group) : new Map();
    const presenterImports: string[] = [];

    if (schemas.size > 0) {
        for (const [schemaName] of schemas) {
            presenterImports.push(schemaName.replace(/Response$/, '') + 'Presenter');
        }
        lines.push(`import { ${presenterImports.join(', ')} } from '${presenterImportPath(tag)}';`);
    }

    // Context type
    if (cfg.context.import) {
        const { typeName, importPath } = parseContextImport(cfg.context.import);
        lines.push(`import type { ${typeName} } from '${importPath}';`);
    } else {
        lines.push(``);
        lines.push(`type ApiContext = {`);
        lines.push(`    baseUrl: string;`);
        lines.push(`    headers?: Record<string, string>;`);
        lines.push(`};`);
    }

    lines.push(``);

    // defineTool config
    const description = group.description ?? `${pascal} operations`;
    lines.push(`export const ${camel}Tools = defineTool<${contextType}>('${escapeTs(tag)}', {`);
    lines.push(`    description: '${escapeTs(description)}',`);

    // Tags feature
    if (cfg.features.tags) {
        lines.push(`    tags: ['${escapeTs(tag)}'],`);
    }

    // toonDescription feature
    if (cfg.features.toonDescription) {
        lines.push(`    toonDescription: true,`);
    }

    lines.push(`    actions: {`);

    // Filter deprecated actions
    const actions = filterActions(group.actions, cfg);

    for (const action of actions) {
        emitAction(lines, action, schemas, cfg);
    }

    lines.push(`    },`);
    lines.push(`});`);

    return {
        path: toolFileName(tag),
        content: lines.join('\n') + '\n',
    };
}

function emitAction(
    lines: string[],
    action: ApiAction,
    schemas: Map<string, SchemaNode>,
    cfg: GeneratorConfig,
): void {
    const name = action.name;
    lines.push(`        ${name}: {`);

    // Description
    if (cfg.features.descriptions && action.summary) {
        lines.push(`            description: '${escapeTs(action.summary)}',`);
    }

    // Annotations
    if (cfg.features.annotations) {
        const annotations = inferAnnotations(action.method);
        for (const [key, value] of Object.entries(annotations)) {
            lines.push(`            ${key}: ${value},`);
        }
    }

    // Deprecated
    if (action.deprecated && cfg.features.deprecated === 'comment') {
        lines.push(`            // ⚠️ DEPRECATED — consider removal`);
    }

    // Presenter binding
    const presenterName = findPresenter(action, schemas);
    if (presenterName) {
        lines.push(`            returns: ${presenterName},`);
    }

    // Input schema (use compileInputSchema which handles coercion + descriptions)
    const hasParams = action.params.length > 0;
    const hasBody = action.requestBody !== undefined;

    if (hasParams || hasBody) {
        const paramsCode = compileInputSchema(action.params, action.requestBody);
        lines.push(`            params: ${paramsCode},`);
    }

    // Handler
    emitHandler(lines, action, presenterName, cfg);

    lines.push(`        },`);
}

function emitHandler(
    lines: string[],
    action: ApiAction,
    presenterName: string | undefined,
    cfg: GeneratorConfig,
): void {
    lines.push(`            handler: async (ctx, args) => {`);

    const url = buildUrlTemplate(action.path);
    const method = action.method.toUpperCase();

    // Build fetch options
    const hasBody = action.requestBody?.properties !== undefined;
    const bodyFields = extractBodyFieldNames(action);

    if (method === 'GET' || method === 'HEAD') {
        lines.push(`                const response = await fetch(${url}, {`);
        lines.push(`                    method: '${method}',`);
        lines.push(`                    headers: { ...ctx.headers },`);
        lines.push(`                });`);
    } else {
        lines.push(`                const response = await fetch(${url}, {`);
        lines.push(`                    method: '${method}',`);
        lines.push(`                    headers: {`);
        lines.push(`                        ...ctx.headers,`);
        if (hasBody) {
            lines.push(`                        'Content-Type': 'application/json',`);
        }
        lines.push(`                    },`);
        if (hasBody && bodyFields.length > 0) {
            lines.push(`                    body: JSON.stringify({`);
            for (const field of bodyFields) {
                lines.push(`                        ${field}: args.${field},`);
            }
            lines.push(`                    }),`);
        }
        lines.push(`                });`);
    }

    lines.push(``);
    lines.push(`                if (!response.ok) {`);
    lines.push(`                    return error(\`\${response.status}: \${response.statusText}\`);`);
    lines.push(`                }`);
    lines.push(``);
    lines.push(`                const data = await response.json();`);
    lines.push(`                return success(data);`);
    lines.push(`            },`);
}

// ── Barrel File ──────────────────────────────────────────

function emitBarrelFile(spec: ApiSpec, cfg: GeneratorConfig): GeneratedFile {
    const contextType = resolveContextType(cfg);
    const lines: string[] = [];

    lines.push(`// Auto-generated by @mcp-fusion/openapi-gen`);
    lines.push(`// Barrel export with pre-built ToolRegistry`);
    lines.push(`// DO NOT EDIT — re-run the generator to update.`);
    lines.push(``);
    lines.push(`import { ToolRegistry } from '@vinkius-core/mcp-fusion';`);

    if (cfg.context.import) {
        const { typeName, importPath } = parseContextImport(cfg.context.import);
        lines.push(`import type { ${typeName} } from '${importPath}';`);
    }

    lines.push(``);

    // Import tools from agents/ directory
    const toolNames: string[] = [];
    for (const group of spec.groups) {
        if (shouldSkipGroup(group, cfg)) continue;
        const camel = toCamelCase(group.tag);
        const toolName = `${camel}Tools`;
        toolNames.push(toolName);
        lines.push(`import { ${toolName} } from './${toolFileName(group.tag).replace('.ts', '.js')}';`);
    }

    lines.push(``);

    // Re-export tools
    lines.push(`export { ${toolNames.join(', ')} };`);
    lines.push(``);

    // Re-export Presenters and Schemas
    if (cfg.features.presenters) {
        for (const group of spec.groups) {
            if (shouldSkipGroup(group, cfg)) continue;
            lines.push(`export * from './${schemaFileName(group.tag).replace('.ts', '.js')}';`);
            lines.push(`export * from './${presenterFileName(group.tag).replace('.ts', '.js')}';`);
        }
        lines.push(``);
    }

    // Build registry
    lines.push(`// ── Registry ────────────────────────────────────────────`);
    lines.push(``);
    lines.push(`export const registry = new ToolRegistry<${contextType}>();`);
    lines.push(`registry.registerAll(${toolNames.join(', ')});`);

    return {
        path: 'index.ts',
        content: lines.join('\n') + '\n',
    };
}

// ── Server File ──────────────────────────────────────────

function emitServerFile(spec: ApiSpec, cfg: GeneratorConfig): GeneratedFile {
    const contextType = resolveContextType(cfg);
    const lines: string[] = [];

    lines.push(`#!/usr/bin/env node`);
    lines.push(`// Auto-generated by @mcp-fusion/openapi-gen`);
    lines.push(`// Complete MCP Server — ready to run`);
    lines.push(`// DO NOT EDIT — re-run the generator to update.`);
    lines.push(``);
    lines.push(`import { Server } from '@modelcontextprotocol/sdk/server/index.js';`);
    lines.push(`import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';`);
    lines.push(`import { registry } from './index.js';`);

    if (cfg.context.import) {
        const { typeName, importPath } = parseContextImport(cfg.context.import);
        lines.push(`import type { ${typeName} } from '${importPath}';`);
    }

    lines.push(``);
    lines.push(`// ── Server Configuration ─────────────────────────────────`);
    lines.push(``);
    lines.push(`const SERVER_NAME = '${escapeTs(cfg.server.name)}';`);
    lines.push(`const SERVER_VERSION = '${escapeTs(cfg.server.version)}';`);
    lines.push(``);
    lines.push(`// ── Context Factory ──────────────────────────────────────`);
    lines.push(``);

    if (cfg.context.import) {
        const { typeName } = parseContextImport(cfg.context.import);
        lines.push(`function createContext(): ${typeName} {`);
    } else {
        lines.push(`type ApiContext = {`);
        lines.push(`    baseUrl: string;`);
        lines.push(`    headers?: Record<string, string>;`);
        lines.push(`};`);
        lines.push(``);
        lines.push(`function createContext(): ApiContext {`);
    }

    lines.push(`    return {`);
    lines.push(`        baseUrl: process.env['API_BASE_URL'] ?? 'http://localhost:3000',`);
    lines.push(`        headers: {`);
    lines.push(`            ...(process.env['API_KEY'] ? { 'Authorization': \`Bearer \${process.env['API_KEY']}\` } : {}),`);
    lines.push(`        },`);
    lines.push(`    };`);
    lines.push(`}`);
    lines.push(``);
    lines.push(`// ── Server Bootstrap ─────────────────────────────────────`);
    lines.push(``);
    lines.push(`async function main(): Promise<void> {`);
    lines.push(`    const server = new Server(`);
    lines.push(`        { name: SERVER_NAME, version: SERVER_VERSION },`);
    lines.push(`        { capabilities: { tools: {} } },`);
    lines.push(`    );`);
    lines.push(``);
    lines.push(`    // Attach all tools from the registry to the MCP server`);
    lines.push(`    registry.attachToServer(server, {`);
    lines.push(`        contextFactory: createContext,`);
    lines.push(`        toolExposition: '${escapeTs(cfg.server.toolExposition)}',`);
    if (cfg.server.actionSeparator !== '_') {
        lines.push(`        actionSeparator: '${escapeTs(cfg.server.actionSeparator)}',`);
    }
    lines.push(`    });`);
    lines.push(``);

    if (cfg.server.transport === 'stdio') {
        lines.push(`    // Start with stdio transport`);
        lines.push(`    const transport = new StdioServerTransport();`);
        lines.push(`    await server.connect(transport);`);
        lines.push(``);
        lines.push(`    console.error(\`\${SERVER_NAME} v\${SERVER_VERSION} running on stdio\`);`);
    }

    lines.push(`}`);
    lines.push(``);
    lines.push(`main().catch((err) => {`);
    lines.push(`    console.error('Fatal error:', err);`);
    lines.push(`    process.exit(1);`);
    lines.push(`});`);

    return {
        path: 'server.ts',
        content: lines.join('\n') + '\n',
    };
}

// ── Helpers ──────────────────────────────────────────────

function collectResponseSchemas(group: ApiGroup): Map<string, SchemaNode> {
    const schemas = new Map<string, SchemaNode>();
    const pascal = toPascalCase(group.tag);

    for (const action of group.actions) {
        const successResponse = action.responses.find(r =>
            r.statusCode.startsWith('2') && r.schema !== undefined
        );

        if (successResponse?.schema) {
            const schemaName = `${pascal}Response`;
            if (!schemas.has(schemaName)) {
                schemas.set(schemaName, successResponse.schema);
            }
        }
    }

    return schemas;
}

function findPresenter(action: ApiAction, schemas: Map<string, SchemaNode>): string | undefined {
    const successResponse = action.responses.find(r =>
        r.statusCode.startsWith('2') && r.schema !== undefined
    );

    if (!successResponse?.schema) return undefined;

    for (const [schemaName] of schemas) {
        return schemaName.replace(/Response$/, '') + 'Presenter';
    }

    return undefined;
}

function extractBodyFieldNames(action: ApiAction): string[] {
    if (!action.requestBody?.properties) return [];
    return Object.keys(action.requestBody.properties);
}

/**
 * Compute relative import path from agents/ to views/ for a given tag.
 * @example 'pet' → '../views/pet.presenter.js'
 */
function presenterImportPath(tag: string): string {
    return `../views/${tag.toLowerCase()}.presenter.js`;
}

/**
 * Compute relative import path from views/ to models/ for a given tag.
 * @example 'pet' → '../models/pet.schema.js'
 */
function schemaImportPath(tag: string): string {
    return `../models/${tag.toLowerCase()}.schema.js`;
}

function resolveContextType(cfg: GeneratorConfig | EmitterConfig): string {
    if ('context' in cfg && cfg.context?.import) {
        return parseContextImport(cfg.context.import).typeName;
    }
    if ('contextImport' in cfg && cfg.contextImport) {
        return parseContextImport(cfg.contextImport).typeName;
    }
    return 'ApiContext';
}

function parseContextImport(importStr: string): { typeName: string; importPath: string } {
    const hashIndex = importStr.lastIndexOf('#');
    if (hashIndex === -1) {
        return { typeName: 'ApiContext', importPath: importStr };
    }
    return {
        typeName: importStr.slice(hashIndex + 1),
        importPath: importStr.slice(0, hashIndex),
    };
}

/** Check if a group should be skipped based on tag filtering */
function shouldSkipGroup(group: ApiGroup, cfg: GeneratorConfig): boolean {
    if (cfg.includeTags.length > 0 && !cfg.includeTags.includes(group.tag)) {
        return true;
    }
    if (cfg.excludeTags.length > 0 && cfg.excludeTags.includes(group.tag)) {
        return true;
    }
    return false;
}

/** Filter actions based on deprecated config */
function filterActions(actions: readonly ApiAction[], cfg: GeneratorConfig): readonly ApiAction[] {
    if (cfg.features.deprecated === 'skip') {
        return actions.filter(a => !a.deprecated);
    }
    return actions;
}

/** Normalize legacy EmitterConfig to GeneratorConfig */
function normalizeConfig(config: GeneratorConfig | EmitterConfig): GeneratorConfig {
    if ('features' in config) {
        return config as GeneratorConfig;
    }
    // Legacy EmitterConfig → GeneratorConfig
    const legacy = config as EmitterConfig;
    return {
        ...DEFAULT_CONFIG,
        ...(legacy.baseUrl !== undefined ? { baseUrl: legacy.baseUrl } : {}),
        context: {
            ...(legacy.contextImport !== undefined ? { import: legacy.contextImport } : {}),
        },
    };
}
