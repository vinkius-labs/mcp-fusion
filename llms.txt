# mcp-fusion

> The MVA (Model-View-Agent) framework for building MCP servers where AI agents are first-class consumers.

## What is mcp-fusion?

mcp-fusion is a TypeScript framework for the Model Context Protocol (MCP) that introduces the **MVA (Model-View-Agent)** architectural pattern â€” created by Renato Marinho at Vinkius Labs. Instead of dumping raw JSON and hoping the AI figures it out, MVA adds a **Presenter** (the View layer) that gives every response structure: validated data, domain rules, rendered charts, action affordances, and cognitive guardrails.

## Core Architecture: MVA (Model-View-Agent)

```
Model (Zod Schema) â†’ View (Presenter) â†’ Agent (LLM)
   validates            perceives          acts
```

The Presenter replaces the human-centric View with an agent-centric perception layer. Every tool response becomes a **structured perception package** â€” not raw JSON.

## Core Concepts

- **MVA Pattern**: Model-View-Agent â€” the architectural foundation where Presenters replace Views
- **Presenter**: **THE core differentiator** â€” domain-level Egress Firewall. Schema validation, JIT system rules, server-rendered UI, action affordances, cognitive guardrails, relational composition. Define once, reuse across every tool and prompt.
- **definePresenter()**: Declarative object-config API â€” auto-rules from Zod `.describe()`, embeds, agentLimit, suggestActions
- **createPresenter()**: Fluent builder for domain-level Presenters â€” `.schema()`, `.systemRules()`, `.uiBlocks()`, `.embed()`
- **initFusion()**: tRPC-style context initialization â€” define context once, every f.tool/f.presenter/f.prompt inherits it
- **GroupedToolBuilder**: Fluent builder that groups related actions into a single MCP tool
- **createTool()**: Factory function to create a GroupedToolBuilder with full Zod power
- **defineTool()**: JSON-first factory â€” define tools without Zod imports using plain strings/objects
- **ResponseBuilder**: Fine-grained manual response composition
- **Action**: A single operation within a grouped tool (e.g., "list", "create", "delete")
- **Group**: Hierarchical namespace for actions (e.g., "users.create", "billing.refund")
- **Discriminator**: The field name the LLM uses to select the action (default: "action")
- **CommonSchema**: Shared Zod schema injected into every action
- **ToolRegistry**: Centralized registry for all tool builders
- **Middleware**: Pre-compiled middleware chains following the next() pattern
- **Tags**: Capability labels for selective tool exposure per session
- **TOON**: Token-Oriented Object Notation for compact descriptions/responses
- **State Sync**: RFC 7234-inspired cache-control signals to prevent temporal blindness
- **Tool Exposition**: Compile-time topology compiler â€” choose flat (one tool per action) or grouped (one tool per builder with discriminator enum) at attach time. Same handlers, different wire format.
- **Select Reflection**: Opt-in `_select` parameter for context window optimization â€” AI agents request only the response fields they need. Uses Late Guillotine pattern (filter wire data AFTER UI/rules generation) to preserve UI integrity. Shallow top-level filtering only.
- **Dynamic Manifest**: RBAC-filtered server capabilities exposed as a native MCP Resource
- **createGroup()**: Functional closure-based tool groups â€” pre-composed middleware, frozen by default, minifies 30-40% better
- **autoDiscover()**: File-based routing â€” scan directory, auto-register tools from file structure
- **createDevServer()**: HMR dev server â€” file changes reload tools, sends MCP notifications/tools/list_changed
- **Standard Schema**: Decouple from Zod â€” `autoValidator()` supports Valibot, ArkType, TypeBox via Standard Schema v1
- **Subpath Exports**: Tree-shakeable imports â€” `mcp-fusion/client`, `/ui`, `/presenter`, `/schema`, `/dev`, `/prompt`
- **Governance Stack**: 8-module introspection layer â€” ToolContract materialization, ContractDiff, BehaviorDigest (SHA-256), CapabilityLockfile (`mcp-fusion.lock`), CryptoAttestation (HMAC-SHA-256), TokenEconomics profiling, EntitlementScanner (blast radius), SemanticProbe (LLM-as-Judge)
- **GovernanceObserver**: Observability bridge â€” wraps governance operations with DebugEvent emission and optional OTel tracing spans
- **CLI**: `fusion lock` / `fusion lock --check` â€” generate, update, and CI-gate the capability lockfile

## Quick Start â€” initFusion() (Recommended)

```typescript
import { initFusion, definePresenter, ui, PromptMessage } from '@vinkius-core/mcp-fusion';
import { z } from 'zod';

interface AppContext { db: PrismaClient; user: { id: string; role: string } }
export const f = initFusion<AppContext>();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STEP 1: THE PRESENTER â€” Egress Firewall & Perception Layer
// Define once. Every tool and prompt that returns invoices uses it.
// BEFORE: handler formats its own response, fields leak, rules live in global prompt
// AFTER:  Presenter validates, strips, renders, truncates, suggests â€” domain-level contract
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
export const InvoicePresenter = definePresenter({
    name: 'Invoice',
    schema: z.object({
        id: z.string(),
        amount_cents: z.number().describe('CRITICAL: in CENTS. Divide by 100 for display.'),
        status: z.enum(['paid', 'pending', 'overdue']),
        client_name: z.string(),
    }),
    // autoRules: true (default) â€” .describe() annotations become JIT system rules
    ui: (inv) => [ui.echarts({ series: [{ type: 'gauge', data: [{ value: inv.amount_cents / 100 }] }] })],
    agentLimit: { max: 50, onTruncate: (n) => ui.summary({ omitted: n, hint: 'Use filters.' }) },
    suggestActions: (inv) => inv.status === 'pending'
        ? [{ tool: 'billing.pay', reason: 'Process payment', args: { id: inv.id } }]
        : [],
    embeds: [{ key: 'client', presenter: ClientPresenter }],
});
// What the Presenter does on EVERY response:
// ðŸ“„ Zod-validated â€” undeclared fields (password_hash, internal IDs) STRIPPED in RAM
// ðŸ“‹ JIT rules â€” "amount is in CENTS" only when invoices are returned
// ðŸ“Š Server-rendered UI â€” ECharts gauge, deterministic
// âš ï¸ Guardrails â€” 10,000 rows â†’ 50 shown + "Use filters."
// ðŸ”— Affordances â€” pending â†’ "â†’ billing.pay"
// ðŸ‘¶ Embeds â€” child Presenters inherit the same pipeline

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STEP 2: TOOLS â€” No Zod Required (JSON descriptors)
// Handler returns raw data. Presenter does the rest.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const getInvoice = f.tool({
    name: 'billing.get_invoice',
    input: { id: 'string' },              // â† JSON descriptor, no Zod import
    readOnly: true,
    returns: InvoicePresenter,             // â† Presenter validates, strips, renders
    handler: async ({ input, ctx }) => {
        return await ctx.db.invoices.findUnique({ where: { id: input.id } });
    },
});

const createInvoice = f.tool({
    name: 'billing.create_invoice',
    input: {
        client_id: 'string',
        amount: { type: 'number', min: 0 },
        currency: { enum: ['USD', 'EUR', 'BRL'] as const },
        notes: { type: 'string', optional: true },
    },
    handler: async ({ input, ctx }) => {
        return await ctx.db.invoices.create({ data: input });
    },
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STEP 3: PROMPTS â€” Powered by the Presenter
// fromView() decomposes Presenter data into XML-tagged messages
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const AuditPrompt = f.prompt('financial_audit', {
    args: {
        invoiceId: 'string',
        depth: { enum: ['quick', 'thorough'] as const },
    } as const,
    handler: async (ctx, { invoiceId, depth }) => {
        const invoice = await ctx.db.invoices.get(invoiceId);
        return {
            messages: [
                PromptMessage.system('You are a Senior Financial Auditor.'),
                // â†“ THE BRIDGE â€” same Presenter, same source of truth
                ...PromptMessage.fromView(InvoicePresenter.make(invoice, ctx)),
                PromptMessage.user(`Perform a ${depth} audit on this invoice.`),
            ],
        };
    },
});

// f.registry() â€” pre-typed
const registry = f.registry();
registry.register(getInvoice);
registry.register(createInvoice);
```

## JSON Param Descriptors (No-Zod API)

Works everywhere â€” `f.tool()`, `defineTool()`, `f.prompt()`, `definePrompt()`:

| Descriptor | Generates |
|---|---|
| `'string'` | `z.string()` |
| `'number'` | `z.number()` |
| `'boolean'` | `z.boolean()` |
| `{ type: 'string', min: 1, max: 100 }` | `z.string().min(1).max(100)` |
| `{ type: 'number', min: 0 }` | `z.number().min(0)` |
| `{ type: 'string', optional: true }` | `z.string().optional()` |
| `{ type: 'string', regex: '^\\d+$' }` | `z.string().regex()` |
| `{ enum: ['a', 'b'] as const }` | `z.enum(['a', 'b'])` |
| `{ type: 'string', description: '...' }` | `z.string().describe('...')` |

## Quick Start â€” MVA with Presenter (Classic Builder)

```typescript
import { createPresenter, ui, defineTool, success } from '@vinkius-core/mcp-fusion';
import { z } from 'zod';

// 1. Define the Presenter â€” the MVA View Layer (builder API)
export const InvoicePresenter = createPresenter('Invoice')
    .schema(z.object({
        id: z.string(),
        amount_cents: z.number(),
        status: z.enum(['paid', 'pending', 'overdue']),
    }))
    .systemRules(['CRITICAL: amount_cents is in CENTS. Divide by 100.'])
    .systemRules((inv, ctx) => ctx?.user?.role !== 'admin' ? ['Mask exact totals.'] : [])
    .uiBlocks((inv) => [
        ui.echarts({ series: [{ type: 'gauge', data: [{ value: inv.amount_cents / 100 }] }] }),
    ])
    .agentLimit(50, (omitted) => ui.summary({ omitted, hint: 'Use filters.' }))
    .suggestActions((inv) =>
        inv.status === 'pending'
            ? [{ tool: 'billing.pay', reason: 'Process payment' }]
            : []
    )
    .embed('client', ClientPresenter);

// 2. Attach to any tool â€” handler returns raw data, Presenter does the rest
const billing = defineTool<AppContext>('billing', {
    actions: {
        get_invoice: {
            returns: InvoicePresenter,
            params: { id: 'string' },
            handler: async (ctx, args) => await ctx.db.invoices.findUnique(args.id),
        },
    },
});

const registry = new ToolRegistry<AppContext>();
registry.register(billing);
registry.attachToServer(server, {
    contextFactory: (extra) => createAppContext(extra),
});
```

## Quick Start â€” defineTool() (No Zod Required)

```typescript
import { defineTool, ToolRegistry, success, error } from '@vinkius-core/mcp-fusion';

const projects = defineTool<AppContext>('projects', {
    description: 'Manage workspace projects',
    shared: { workspace_id: 'string' },
    actions: {
        list: {
            readOnly: true,
            params: { status: { enum: ['active', 'archived'] as const, optional: true } },
            handler: async (ctx, args) => success(await ctx.db.projects.findMany()),
        },
        create: {
            params: {
                name: { type: 'string', min: 1, max: 100 },
                email: { type: 'string', regex: '^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$' },
            },
            handler: async (ctx, args) => success(await ctx.db.projects.create(args)),
        },
        delete: {
            destructive: true,
            params: { project_id: 'string' },
            handler: async (ctx, args) => {
                await ctx.db.projects.delete(args.project_id);
                return success('Project deleted');
            },
        },
    },
});
```

## Quick Start â€” createTool() (Full Zod Power)

```typescript
import { createTool, ToolRegistry, success, error } from '@vinkius-core/mcp-fusion';
import { z } from 'zod';

const projects = createTool<AppContext>('projects')
    .description('Manage workspace projects')
    .commonSchema(z.object({
        workspace_id: z.string().describe('Workspace identifier'),
    }))
    .action({
        name: 'list',
        readOnly: true,
        schema: z.object({ status: z.enum(['active', 'archived']).optional() }),
        handler: async (ctx, args) => success(await ctx.db.projects.findMany({ where: args })),
    })
    .action({
        name: 'create',
        schema: z.object({ name: z.string() }),
        handler: async (ctx, args) => success(await ctx.db.projects.create({ data: args })),
    })
    .action({
        name: 'delete',
        destructive: true,
        schema: z.object({ project_id: z.string() }),
        handler: async (ctx, args) => {
            await ctx.db.projects.delete({ where: { id: args.project_id } });
            return success('Deleted');
        },
    });
```

## Presenter API â€” Egress Firewall & Perception Layer

The Presenter is the domain-level egress contract between your handler and the wire. It solves the fundamental problem of every MCP server: the handler owns the response shape, so validation, formatting, and security are ad-hoc, duplicated, and invisible to audits.

BEFORE: Handler formats its own response. Fields chosen ad-hoc. password_hash leaks. Rules live in global prompt. 10,000 rows crash the agent. Response format drifts between tools.
AFTER: Handler returns raw data. Presenter validates through Zod (stripping undeclared fields in RAM), injects JIT domain rules, renders UI server-side, truncates with guidance, and suggests next actions. One Presenter per entity, reused everywhere.

### definePresenter() â€” Object Config (Recommended)

```typescript
import { definePresenter, ui } from '@vinkius-core/mcp-fusion';

const InvoicePresenter = definePresenter({
    name: 'Invoice',
    schema: z.object({
        id: z.string(),
        amount_cents: z.number().describe('CRITICAL: in CENTS. Divide by 100.'),
        status: z.enum(['paid', 'pending', 'overdue']),
    }),
    // autoRules: true (default) â€” Zod .describe() annotations auto-extracted as system rules
    ui: (inv) => [ui.echarts({ series: [{ type: 'gauge', data: [{ value: inv.amount_cents / 100 }] }] })],
    collectionUi: (items) => [ui.summary({ total: items.length, showing: Math.min(items.length, 50) })],
    agentLimit: { max: 50, onTruncate: (n) => ui.summary({ omitted: n, hint: 'Use filters.' }) },
    suggestActions: (inv) => inv.status === 'pending'
        ? [{ tool: 'billing.pay', reason: 'Process payment', args: { id: inv.id } }] : [],
    embeds: [{ key: 'client', presenter: ClientPresenter }],
});
```

### createPresenter() â€” Fluent Builder

```typescript
import { createPresenter, ui } from '@vinkius-core/mcp-fusion';

const UserPresenter = createPresenter('User')
    .schema(z.object({ id: z.string(), name: z.string(), role: z.string() }))
    .systemRules(['Display name in bold'])
    .systemRules((user, ctx) => ctx.isAdmin ? ['Show internal fields'] : ['Hide internal fields'])
    .uiBlocks((user) => [ui.summary({ total: 1, showing: 1 })])
    .agentLimit(50, { warningMessage: 'Showing {shown} of {total}. Use filters.' })
    .suggestActions((user) => [
        { tool: 'users.update', reason: 'Edit this user', args: { id: user.id } },
    ])
    .embed('team', TeamPresenter);
```

### Presenter Layers

| Layer | What It Does | Why |
|---|---|---|
| Egress Firewall | `.parse()` strips undeclared fields in RAM | PII, passwords gone before wire |
| JIT System Rules | Rules travel with data, not global prompt | Zero wasted tokens |
| Server-Rendered UI | ECharts, Mermaid â€” deterministic | No hallucinated charts |
| Cognitive Guardrails | `.agentLimit()` truncates + guidance | No OOM, no context explosion |
| Action Affordances | `.suggestActions()` | Eliminates hallucinated guesswork |
| Relational Composition | `.embed()` / `embeds:` | Child Presenters inherit full pipeline |
| Prompt Bridge | `PromptMessage.fromView()` | Same source of truth for tools AND prompts |

## Presenter Composition

```typescript
const OrderPresenter = createPresenter('Order')
    .schema(OrderSchema)
    .embed('customer', CustomerPresenter)
    .embed('items', LineItemPresenter);
// Child Presenters' rules, UI blocks, and suggestions are automatically merged.
```

## Select Reflection â€” Context Window Optimization

Opt-in feature that injects a `_select` parameter into the input schema, allowing AI agents to request only the response fields they need. Reduces token waste by up to 80% on large payloads.

**Late Guillotine Pattern**: UI blocks, system rules, and action suggestions always receive the FULL data. Only the wire-facing data block sent to the AI is filtered. This ensures UI integrity â€” charts, rules, and suggestions never break due to missing fields.

**Shallow filtering only**: `_select` lists top-level keys. Nested objects are returned whole when selected.

```typescript
import { createTool, createPresenter } from '@vinkius-core/mcp-fusion';
import { z } from 'zod';

const InvoicePresenter = createPresenter('Invoice')
    .schema(z.object({
        id: z.string(),
        status: z.enum(['paid', 'pending', 'overdue']),
        amount_cents: z.number(),
        client: z.object({ name: z.string(), email: z.string() }),
    }));

const billing = createTool<AppContext>('billing')
    .enableSelect()  // â† opt-in: inject _select into input schema
    .action({
        name: 'get_invoice',
        schema: z.object({ id: z.string() }),
        returns: InvoicePresenter,
        handler: async (ctx, args) => await ctx.db.invoices.findUnique(args.id),
    });

// Generated input schema includes:
// _select: { type: 'array', items: { enum: ['amount_cents', 'client', 'id', 'status'] } }
//
// AI sends: { action: 'get_invoice', id: '123', _select: ['status'] }
// Response: { status: 'paid' }  â† instead of full invoice
//
// UI blocks still render with full data (Late Guillotine)
```

**Security**: Enum whitelist from Presenter schema keys (AI cannot request arbitrary fields). `Object.hasOwn()` in pickFields blocks prototype pollution. Subtractive-only design (can only remove fields, never add data). Disabled by default.

## ResponseBuilder (Manual Composition)

```typescript
import { ResponseBuilder } from '@vinkius-core/mcp-fusion';

const response = ResponseBuilder.create(data)
    .systemRules(['Format currency in USD'])
    .uiBlock(ui.echarts({ /* chart config */ }))
    .llmHint('This invoice is overdue')
    .suggestActions([{ tool: 'billing.pay', reason: 'Pay now' }])
    .build();
```

## DX Shortcuts

```typescript
import { response, ui } from '@vinkius-core/mcp-fusion';

return response.ok(data);                          // Simple success
return response.withRules(data, ['Rule 1']);        // Data + rules
ui.echarts({ series: [...] });                     // ECharts chart
ui.mermaid('graph TD; A-->B');                      // Mermaid diagram
ui.summary({ total: 100, showing: 10 });           // Collection summary
```

## Hierarchical Groups

```typescript
const platform = createTool<AppContext>('platform')
    .tags('core')
    .group('users', 'User management', g => {
        g.use(requireAdmin)
         .action({ name: 'list', readOnly: true, handler: listUsers })
         .action({ name: 'ban', destructive: true, schema: banSchema, handler: banUser });
    })
    .group('billing', 'Billing operations', g => {
        g.action({ name: 'refund', destructive: true, schema: refundSchema, handler: issueRefund });
    });
// Discriminator values: "users.list" | "users.ban" | "billing.refund"
```

## Middleware

```typescript
const requireAuth: MiddlewareFn<AppContext> = async (ctx, args, next) => {
    if (!ctx.user) return error('Unauthorized');
    return next();
};

// tRPC-style context derivation
const withDb = defineMiddleware(async (ctx) => ({
    ...ctx,
    db: await createDbConnection(ctx.tenantId),
}));

createTool<AppContext>('projects')
    .use(requireAuth)
    .use(withDb)
    .action({ name: 'list', handler: async (ctx, args) => success(await ctx.db.query()) });
```

## Self-Healing Errors

```typescript
import { toolError } from '@vinkius-core/mcp-fusion';

return toolError('INVALID_DATE_RANGE', {
    message: 'Start date must be before end date',
    suggestion: 'Swap the date values and retry.',
    availableActions: ['calendar.list'],
    severity: 'error',             // 'warning' | 'error' | 'critical'
    details: { start: args.start, end: args.end },
    retryAfter: 0,                 // retry immediately (seconds)
});
```

### ErrorCode Union (15 canonical codes + custom strings)

`NOT_FOUND`, `VALIDATION_ERROR`, `UNAUTHORIZED`, `FORBIDDEN`, `CONFLICT`, `RATE_LIMITED`, `TIMEOUT`, `INTERNAL_ERROR`, `DEPRECATED`, `MISSING_REQUIRED_FIELD`, `UNKNOWN_ACTION`, `MISSING_DISCRIMINATOR`, `UNKNOWN_TOOL`, `SERVER_BUSY`, `AUTH_REQUIRED`, or any custom string.

### Severity Levels

| Severity | `isError` | Use Case |
|---|---|---|
| `warning` | `false` | Non-fatal advisories (deprecation, soft limits) |
| `error` | `true` | Standard recoverable errors (default) |
| `critical` | `true` | System-level failures requiring escalation |

### XML Output Format

```xml
<tool_error code="NOT_FOUND" severity="error">
<message>Invoice not found.</message>
<recovery>Call billing.list first.</recovery>
<available_actions>
  <action>billing.list</action>
</available_actions>
<details>
  <detail key="entity_id">inv_123</detail>
  <detail key="entity_type">invoice</detail>
</details>
<retry_after>5 seconds</retry_after>
</tool_error>
```

All error XML output is automatically escaped to prevent injection. Detail keys are rendered as XML attributes (safe for any string). Pipeline errors use structured codes: `MISSING_DISCRIMINATOR`, `UNKNOWN_ACTION`, `UNKNOWN_TOOL`, `MISSING_REQUIRED_FIELD`.

## State Sync

```typescript
registry.attachToServer(server, {
    contextFactory: (extra) => createAppContext(extra),
    stateSync: {
        defaults: { cacheControl: 'no-store' },
        policies: [
            { match: 'sprints.update', invalidates: ['sprints.*'] },
            { match: 'tasks.update',   invalidates: ['tasks.*', 'sprints.*'] },
            { match: 'countries.*',    cacheControl: 'immutable' },
        ],
        onInvalidation: (event) => {
            // event: { causedBy: string, patterns: string[], timestamp: number }
            metrics.increment('cache.invalidations', { tool: event.causedBy });
        },
        notificationSink: (notification) => {
            // notification: { method: 'notifications/resources/updated', params: { uri: 'fusion://stale/sprints.*' } }
            server.notification(notification);
        },
    },
});
```

### Policy Overlap Detection

```typescript
import { detectOverlaps } from '@vinkius-core/mcp-fusion';

const warnings = detectOverlaps([
    { match: 'sprints.*', cacheControl: 'no-store' },
    { match: 'sprints.update', invalidates: ['sprints.*'] },  // shadowed by index 0
]);
// warnings[0]: { shadowingIndex: 0, shadowedIndex: 1, message: '...' }
```

Static analysis utility â€” call at server startup to catch first-match-wins ordering bugs.

## Runtime Guards

Built-in concurrency control and payload size limiting. Fulfills the MCP spec requirement: "Servers MUST rate limit tool invocations."

```typescript
// Concurrency Limiter â€” limit simultaneous executions per tool
const billing = createTool<AppContext>('billing')
    .concurrency({ maxActive: 5, maxQueue: 20 })
    .action({
        name: 'process_invoice',
        handler: async (ctx, args) => success(await ctx.stripe.charges.create(args)),
    });
// 5 concurrent, 20 queued, rest rejected with SERVER_BUSY

// Egress Guard â€” truncate oversized responses
const logs = createTool<AppContext>('logs')
    .maxPayloadBytes(2 * 1024 * 1024) // 2MB
    .action({
        name: 'search',
        handler: async (ctx, args) => success(await ctx.db.logs.findMany(args)),
    });
// Responses > 2MB are truncated + system intervention injected

// Both combined
const analytics = createTool<AppContext>('analytics')
    .concurrency({ maxActive: 3, maxQueue: 10 })
    .maxPayloadBytes(2 * 1024 * 1024)
    .action({
        name: 'query',
        handler: async (ctx, args) => success(await ctx.db.$queryRaw(args.sql)),
    });

// Intent Mutex â€” anti-race condition guard
const users = createTool<AppContext>('users')
    .action({
        name: 'delete',
        destructive: true, // Automatically serializes concurrent calls to this action key
        handler: async (ctx, args) => success(await ctx.db.users.delete(args.id)),
    });
```

Load shedding returns `toolError('SERVER_BUSY')` â€” a self-healing error that causes the LLM to reduce its cadence. Egress truncation injects `[SYSTEM INTERVENTION: Payload truncated. You MUST use pagination.]`. Intent Mutex prevents LLM double-firing hallucinations. Zero overhead when not configured.


## Dynamic Manifest

```typescript
registry.attachToServer(server, {
    contextFactory: (extra) => createAppContext(extra),
    serverName: 'my-platform',
    introspection: {
        enabled: process.env.NODE_ENV !== 'production',
        filter: (manifest, ctx) => {
            if (ctx.user.role !== 'admin') {
                delete manifest.capabilities.tools['admin'];
            }
            return manifest;
        },
    },
});
// Exposes fusion://manifest.json via MCP resources/list + resources/read
// Manifest includes: all tools, actions (destructive/readOnly flags, required_fields),
// input schemas, presenter references â€” RBAC-filtered per session
```

## Tag Filtering

```typescript
registry.attachToServer(server, { filter: { tags: ['core'] } });      // Only core tools
registry.attachToServer(server, { filter: { exclude: ['internal'] } }); // No internal tools
```

## Tool Exposition

Two strategies for the same codebase â€” choose at attach time:

```typescript
// Flat (default) â€” each action becomes an independent MCP tool
// projects â†’ projects_list, projects_create, projects_delete
registry.attachToServer(server, {
    toolExposition: 'flat',
    actionSeparator: '_',
});

// Grouped â€” one MCP tool per builder with discriminator enum
// projects â†’ { action: 'list' | 'create' | 'delete' }
registry.attachToServer(server, {
    toolExposition: 'grouped',
});
```

**Flat** â€” precision per action: isolated schemas, per-action MCP annotations, per-tool toggles in clients. Best for small-to-medium APIs and weaker LLMs.

**Grouped** â€” density at scale: one schema, one description, shared params appear once. Best for large domain APIs (50+ actions) and token-constrained contexts.

MCP annotation semantics: Fusion emits `destructiveHint: false` on non-destructive actions because the MCP spec defaults `destructiveHint` to `true` (assume dangerous). Read-only actions get both `readOnlyHint: true` and `destructiveHint: false`. Destructive actions get `destructiveHint: true`. `readOnlyHint: false` is never emitted (matches spec default).

## Response Helpers

```typescript
import { success, error, required, toonSuccess, toolError } from '@vinkius-core/mcp-fusion';

return success('Task completed');
return success({ id: '123', name: 'Acme' });
return error('Project not found');
return error('Project not found', 'NOT_FOUND');   // with optional code
return required('workspace_id');
return toonSuccess(users);                         // ~40% fewer tokens
return toolError('NOT_FOUND', {
    message: 'Invoice not found',
    suggestion: 'Call billing.list first.',
    availableActions: ['billing.list'],
    severity: 'error',
    details: { entity_type: 'invoice' },
    retryAfter: 30,
});
```

## Streaming Progress

Generator handlers yield `progress()` events that are **automatically** forwarded to the MCP client as `notifications/progress` when the client includes a `progressToken` in its request `_meta`. Zero configuration, zero overhead when not used.

```typescript
handler: async function* (ctx, args) {
    yield progress(25, 'Loading data...');
    const data = await ctx.db.query();
    yield progress(75, 'Processing...');
    return success(data);
}
// Wire format: { method: 'notifications/progress', params: { progressToken, progress: 25, total: 100, message: 'Loading data...' } }
```

## Prompt Engine â€” Powered by the Presenter

Server-side hydrated prompt templates with schema-informed coercion and lifecycle sync. The `definePrompt()` factory enforces a **flat schema constraint** â€” prompt arguments must be primitives (string, number, boolean, enum) because MCP clients render them as forms. **No Zod required** â€” JSON descriptors work everywhere.

```typescript
import { definePrompt, PromptMessage } from '@vinkius-core/mcp-fusion';

// No-Zod prompt â€” JSON descriptors for args
const SummarizePrompt = definePrompt<AppContext>('summarize', {
    title: 'Summarize Document',
    description: 'Generate a summary of a document.',
    args: {
        docId: 'string',
        length: { enum: ['short', 'medium', 'long'] as const },
    } as const,
    handler: async (ctx, { docId, length }) => {
        const doc = await ctx.db.documents.get(docId);
        return {
            messages: [
                PromptMessage.system('You are a Senior Technical Writer.'),
                PromptMessage.user(`Summarize this document (${length}):\n\n${doc.content}`),
            ],
        };
    },
});

// f.prompt() â€” context-typed, same No-Zod DX
const ReviewPrompt = f.prompt('code_review', {
    args: {
        prUrl: { type: 'string', description: 'GitHub PR URL' },
        depth: { enum: ['quick', 'thorough', 'security'] as const },
    } as const,
    handler: async (ctx, { prUrl, depth }) => {
        const pr = await ctx.github.getPullRequest(prUrl);
        return {
            messages: [
                PromptMessage.system(`You are a Senior ${depth} Code Reviewer.`),
                PromptMessage.user(`Review this PR:\n\n${pr.diff}`),
            ],
        };
    },
});
```

## Hydration Timeout Sandbox

Prompt handlers fetch data from external sources (APIs, databases). If any source hangs, the UI freezes. The Hydration Timeout Sandbox wraps the handler in a strict `Promise.race` deadline. Three guarantees: (1) handler completes â†’ normal result, (2) handler exceeds deadline â†’ `<hydration_alert><status>TIMEOUT</status>` alert, (3) handler throws â†’ `<hydration_alert><status>ERROR</status>` alert. The UI ALWAYS unblocks.

```typescript
// Per-prompt deadline
const Briefing = definePrompt<AppContext>('morning_briefing', {
    hydrationTimeout: 3000, // 3 seconds strict
    handler: async (ctx, args) => {
        // If Jira takes 15s, framework cuts at 3s â†’ returns SYSTEM ALERT
        const tickets = await ctx.invokeTool('jira.get_assigned');
        return { messages: [PromptMessage.user(tickets.text)] };
    },
});

// Registry-level default (global safety net)
const prompts = new PromptRegistry<AppContext>();
prompts.setDefaultHydrationTimeout(5000); // 5s for all prompts
prompts.register(Briefing); // overrides with 3s
```

Zero overhead when no timeout configured. Timer cleanup via `finally` â€” no resource leaks. Interceptors still run after timeout.

## MVA-Driven Prompts â€” The Presenter Bridge

`PromptMessage.fromView()` extends the Presenterâ€™s egress contract to Prompts. It decomposes a Presenterâ€™s `ResponseBuilder` into XML-tagged prompt messages (`<domain_rules>`, `<dataset>`, `<visual_context>`, `<system_guidance>`) optimized for frontier LLMs. Domain rules, UI blocks, and action suggestions from the Presenter are automatically extracted â€” **single source of truth between tools and prompts.** The same InvoicePresenter that governs tool responses also governs prompt context.

```typescript
const AuditPrompt = definePrompt<AppContext>('audit', {
    args: { invoiceId: 'string' } as const,
    handler: async (ctx, { invoiceId }) => {
        const invoice = await ctx.db.getInvoice(invoiceId);
        return {
            messages: [
                PromptMessage.system('You are a Senior Financial Auditor.'),
                ...PromptMessage.fromView(InvoicePresenter.make(invoice, ctx)),
                PromptMessage.user('Begin the audit.'),
            ],
        };
    },
});
```

## Stateless Cursor Pagination

Prompt Registries support cryptographic, stateless cursor-based pagination out of the box. Cursors encode the current position securely (`globalThis.crypto.subtle`) ensuring O(1) memory overhead.

```typescript
const registry = new PromptRegistry<AppContext>();
registry.configurePagination({ pageSize: 50 }); // enable pagination
```

## Important Rules

1. `.action()` and `.group()` are MUTUALLY EXCLUSIVE on the same builder
2. Action names must NOT contain dots (dots are reserved for group.action keys)
3. After `buildToolDefinition()`, the builder is FROZEN â€” no more modifications
4. `execute()` auto-calls `buildToolDefinition()` if not already called
5. `commonSchema` fields are marked `(always required)` in auto-generated descriptions
6. Zod `.merge().strip()` is used at runtime â€” unknown fields are silently stripped
7. Middleware chains are pre-compiled at build time â€” zero runtime allocation
8. Tool names must be unique across a ToolRegistry
9. Presenters are immutable after creation â€” define once, reuse across tools
10. `.agentLimit()` automatically truncates and injects guidance blocks

## Public API (all from '@vinkius-core/mcp-fusion')

### Context Initialization (v2.7+)
- `initFusion<TContext>()` â†’ FusionInstance â€” define context once, inherit everywhere
- `FusionInstance<TContext>` â€” .tool(), .presenter(), .prompt(), .middleware(), .defineTool(), .registry()
- `f.tool(config)` â†’ GroupedToolBuilder â€” handler receives `{ input, ctx }` (tRPC-style)
- `f.presenter(config)` â†’ Presenter â€” delegates to `definePresenter()`
- `f.prompt(name, config)` â†’ PromptBuilder â€” context-typed prompt
- `f.middleware(deriveFn)` â†’ MiddlewareDefinition â€” context derivation
- `f.defineTool(name, config)` â†’ GroupedToolBuilder â€” full ToolConfig power
- `f.registry()` â†’ ToolRegistry â€” pre-typed registry
- `FusionToolConfig<TContext, TInput>` â€” { name, description?, input?, tags?, annotations?, readOnly?, destructive?, idempotent?, middleware?, returns?, handler }

### Declarative Presenter (v2.7+)
- `definePresenter(config)` â†’ Presenter â€” object-config API with auto-rules from Zod `.describe()`
- `PresenterConfig<T>` â€” { name, schema?, rules?, ui?, collectionUi?, agentLimit?, suggestActions?, embeds?, autoRules? }
- `AgentLimitDef` â€” { max: number, onTruncate: (omittedCount) => UiBlock }
- `EmbedDef` â€” { key: string, presenter: Presenter }
- `extractZodDescriptions(schema)` â†’ string[] â€” walks Zod AST extracting `.describe()` annotations

### Functional Groups (v2.7+)
- `createGroup<TContext>(config)` â†’ CompiledGroup â€” closure-based, frozen, pre-composed middleware
- `GroupConfig<TContext>` â€” { name, description?, tags?, middleware?, actions }
- `GroupAction<TContext>` â€” { description?, schema?, readOnly?, destructive?, idempotent?, middleware?, handler }
- `CompiledGroup<TContext>` â€” .name, .description, .tags, .actionNames, .execute(ctx, action, args), .getAction(name)

### File-Based Routing (v2.7+)
- `autoDiscover(registry, dir, options?)` â€” scan directory, auto-register tool builders
- `AutoDiscoverOptions` â€” { pattern?, recursive?, loader?, resolve? }

### Dev Server (v2.7+, from 'mcp-fusion/dev')
- `createDevServer(config)` â†’ DevServer â€” HMR-enabled development server
- `DevServerConfig` â€” { dir, extensions?, debounce?, setup, onReload?, server? }
- `DevServer` â€” .start(), .stop(), .reload(reason?)

### Standard Schema (v2.7+, from 'mcp-fusion/schema')
- `StandardSchemaV1<TInput, TOutput>` â€” universal validator contract interface
- `FusionValidator<T>` â€” .validate(value) â†’ ValidationResult, .vendor, .schema
- `toStandardValidator(schema)` â†’ FusionValidator â€” wrap Standard Schema v1 (Valibot, ArkType, etc.)
- `fromZodSchema(schema)` â†’ FusionValidator â€” wrap Zod via safeParse()
- `autoValidator(schema)` â†’ FusionValidator â€” auto-detect schema type and wrap
- `isStandardSchema(value)` â†’ boolean â€” duck-type check for Standard Schema v1
- `ValidationResult<T>` â€” { success: true, data: T } | { success: false, issues: StandardSchemaIssue[] }
- `InferStandardOutput<T>` â€” infer output type from Standard Schema

### Subpath Exports (v2.7+)
- `@vinkius-core/mcp-fusion` â€” full framework
- `@vinkius-core/mcp-fusion/client` â€” FusionClient only
- `@vinkius-core/mcp-fusion/ui` â€” UI blocks only
- `@vinkius-core/mcp-fusion/presenter` â€” Presenter + definePresenter
- `@vinkius-core/mcp-fusion/prompt` â€” Prompt engine
- `@vinkius-core/mcp-fusion/state-sync` â€” State Sync layer
- `@vinkius-core/mcp-fusion/observability` â€” Debug observers + tracing
- `@vinkius-core/mcp-fusion/dev` â€” autoDiscover + createDevServer
- `@vinkius-core/mcp-fusion/schema` â€” Standard Schema adapters
- `@vinkius-core/mcp-fusion/testing` â€” FusionTester

### Builder
- `createTool<TContext>(name)` â†’ GroupedToolBuilder (fluent builder, requires Zod)
- `defineTool<TContext>(name, config)` â†’ GroupedToolBuilder (JSON-first, no Zod required)
- `GroupedToolBuilder<TContext>` â€” .description(), .commonSchema(), .discriminator(), .tags(), .annotations(), .toonDescription(), .enableSelect(), .concurrency(), .maxPayloadBytes(), .use(), .action(), .group(), .buildToolDefinition(), .execute(), .previewPrompt(), .getName(), .getTags(), .getActionNames(), .getActionMetadata(), .getSelectEnabled()
- `ActionGroupBuilder<TContext>` â€” .use(), .action()

### Presenter (MVA View Layer)
- `createPresenter(name)` â†’ PresenterBuilder â€” .schema(), .systemRules(), .uiBlocks(), .agentLimit(), .suggestActions(), .embed()
- `ResponseBuilder.create(data)` â†’ ResponseBuilder â€” .systemRules(), .uiBlock(), .llmHint(), .suggestActions(), .build()
- `ui.echarts(config)` â†’ UIBlock (ECharts chart)
- `ui.mermaid(code)` â†’ UIBlock (Mermaid diagram)
- `ui.summary(stats)` â†’ UIBlock (Collection summary)
- `response.ok(data)` â†’ ToolResponse (success shortcut)
- `response.withRules(data, rules)` â†’ ToolResponse (data + system rules)

### Select Reflection (v2.11+)
- `extractZodKeys(schema)` â†’ string[] â€” recursively unwrap Zod wrappers to extract top-level object keys
- `pickFields(data, selectSet)` â†’ filtered object â€” shallow top-level field picker with Object.hasOwn() guard
- `applySelectFilter(data, selectFields, isArray)` â†’ filtered data â€” applies pickFields to single objects or arrays
- `.enableSelect()` â†’ GroupedToolBuilder â€” opt-in: inject `_select` parameter into input schema
- `.getSelectEnabled()` â†’ boolean â€” AST reflection: check if select is enabled

### Registry
- `ToolRegistry<TContext>` â€” .register(), .registerAll(), .getAllTools(), .getTools(filter), .routeCall(), .attachToServer(), .has(), .clear(), .size

### FusionClient (tRPC-style)
- `createFusionClient<TRouter>(transport, options?)` â†’ FusionClient â€” type-safe client with autocomplete, middleware, error parsing
- `FusionClient<TRouter>` â€” .execute(action, args) with full type inference, .executeBatch(calls, options?) for parallel/sequential batch execution
- `FusionClientError` â€” Structured error class: code, message, recovery, availableActions, severity, raw
- `ClientMiddleware` â€” `(action, args, next) => Promise<ToolResponse>` â€” request interceptor type
- `FusionClientOptions` â€” `{ middleware?: ClientMiddleware[], throwOnError?: boolean }`

### Response Helpers
- `success(data)` â†’ ToolResponse
- `error(message, code?)` â†’ ToolResponse (isError: true, optional code attribute)
- `required(field)` â†’ ToolResponse (isError: true)
- `toolError(code, options)` â†’ ToolResponse (structured recovery hints with severity, details, retryAfter)
- `toonSuccess(data, options?)` â†’ ToolResponse (TOON-encoded)
- `ErrorCode` â€” Union type: 15 canonical codes + custom strings
- `ErrorSeverity` â€” `'warning' | 'error' | 'critical'`

### State Sync
- `StateSyncConfig` â€” { defaults?, policies, onInvalidation?, notificationSink? }
- `InvalidationEvent` â€” { causedBy: string, patterns: string[], timestamp: number }
- `ResourceNotification` â€” { method: string, params: { uri: string } }
- `detectOverlaps(policies)` â†’ OverlapWarning[] â€” static analysis for policy shadowing
- `OverlapWarning` â€” { shadowingIndex: number, shadowedIndex: number, message: string }

### Dynamic Manifest
- `registerIntrospectionResource(server, config, serverName, builders, contextFactory?)` â€” registers MCP resources/list + resources/read handlers
- `compileManifest(serverName, builders)` â†’ ManifestPayload (structured server capabilities)
- `cloneManifest(manifest)` â†’ deep clone for RBAC isolation
- `Presenter.getSchemaKeys()` â†’ string[] (read-only accessor)
- `Presenter.getUiBlockTypes()` â†’ string[] (read-only accessor)
- `Presenter.hasContextualRules()` â†’ boolean (read-only accessor)
- `ToolRegistry.getBuilders()` â†’ Iterable<ToolBuilder> (for introspection)

### Streaming Progress
- `progress(percent, message)` â†’ ProgressEvent (yield from generator handlers)
- `isProgressEvent(value)` â†’ type guard
- `ProgressSink` â€” callback type `(event: ProgressEvent) => void` â€” auto-wired by `attachToServer()`, or pass manually to `execute()` / `routeCall()` for testing

### Prompt Engine
- `definePrompt<TContext>(name, config)` â†’ PromptBuilder â€” JSON-first or Zod schema for args, flat primitives only
- `PromptMessage.system(text)` â†’ PromptMessagePayload (system instruction as MCP user role)
- `PromptMessage.user(text)` â†’ PromptMessagePayload
- `PromptMessage.assistant(text)` â†’ PromptMessagePayload (multi-turn seeding)
- `PromptMessage.image(role, data, mimeType)` â†’ PromptMessagePayload
- `PromptMessage.audio(role, data, mimeType)` â†’ PromptMessagePayload
- `PromptMessage.resource(role, uri, options?)` â†’ PromptMessagePayload
- `PromptMessage.fromView(builder)` â†’ PromptMessagePayload[] â€” decomposes ResponseBuilder into XML-tagged messages (<domain_rules>, <dataset>, <visual_context>, <system_guidance>)
- `PromptRegistry<TContext>` â€” .register(), .registerAll(), .getAllPrompts(), .getPrompts(filter), .routeGet(), .setDefaultHydrationTimeout(), .notifyChanged(), .has(), .clear(), .size

### Result Monad
- `succeed<T>(value)` â†’ Success<T>
- `fail(response)` â†’ Failure
- `Result<T>` = Success<T> | Failure

### Middleware
- `defineMiddleware(deriveFn)` â†’ MiddlewareDefinition (tRPC-style context derivation)
- `resolveMiddleware(input)` â†’ MiddlewareFn

### Observability
- `createDebugObserver(options?)` â†’ Observer for runtime debugging
- Event types: route, validate, middleware, execute, error, governance
- `GovernanceEvent` â€” { type: 'governance', operation: GovernanceOperation, label: string, outcome: 'ok' | 'fail', detail?: string, durationMs: number, timestamp: number }
- `GovernanceOperation` â€” `'contract.compile' | 'contract.diff' | 'digest.compute' | 'lockfile.generate' | 'lockfile.check' | 'lockfile.write' | 'lockfile.read' | 'attestation.sign' | 'attestation.verify' | 'entitlement.scan' | 'token.profile'`
- `createGovernanceObserver(config)` â†’ GovernanceObserver â€” wraps governance operations with debug events and optional tracing spans
- `createNoopObserver()` â†’ GovernanceObserver â€” zero-overhead passthrough
- `GovernanceObserverConfig` â€” { debug?: DebugObserverFn, tracer?: FusionTracer }
- `GovernanceObserver` â€” .observe(operation, label, fn), .observeAsync(operation, label, fn)

### Tracing (OpenTelemetry-Compatible)
- `FusionTracer` / `FusionSpan` â€” structural subtyping interfaces matching OpenTelemetry (no `@opentelemetry/api` dependency)
- `SpanStatusCode` â€” exported constants: `UNSET` (0), `OK` (1), `ERROR` (2)
- `.tracing(tracer)` on builders â€” per-tool tracing
- `ToolRegistry.enableTracing(tracer)` â€” propagate to all builders
- `AttachOptions.tracing` â€” pass tracer to `attachToServer()` for full server tracing
- **Error classification**: AI errors (`validation_failed`, `missing_discriminator`, `unknown_action`, `unknown_tool`, `handler_returned_error`) â†’ `SpanStatusCode.UNSET` (no PagerDuty). System errors (handler `throw`) â†’ `SpanStatusCode.ERROR` (triggers alerts).
- **Enterprise attributes**: `mcp.system`, `mcp.tool`, `mcp.action`, `mcp.durationMs`, `mcp.isError`, `mcp.error_type`, `mcp.tags`, `mcp.description`, `mcp.response_size`
- **Span events**: `mcp.route`, `mcp.validate` (with `mcp.valid`, `mcp.durationMs`), `mcp.middleware` (with `mcp.chainLength`)
- Zero overhead when no tracer is set â€” separate fast path

### Types
- `ToolResponse` â€” { content: [{ type: "text", text: string }], isError?: boolean }
- `MiddlewareFn<TContext>` â€” (ctx, args, next) => Promise<ToolResponse>
- `ActionConfig<TContext>` â€” { name, description?, schema?, destructive?, readOnly?, handler, returns? }
- `PresenterConfig` â€” { schema, systemRules?, uiBlocks?, agentLimit?, suggestActions?, embeds? }
- `ToolBuilder<TContext>` â€” Interface for custom builders
- `ActionMetadata` â€” { key, actionName, groupName, description, destructive, idempotent, readOnly, requiredFields, hasMiddleware, presenterName?, presenterSchemaKeys?, presenterUiBlockTypes?, presenterHasContextualRules? }
- `ToolFilter` â€” { tags?: string[], exclude?: string[] }
- `AttachOptions<TContext>` â€” { contextFactory?, filter?, debug?, stateSync?, introspection?, serverName?, toolExposition?, actionSeparator?, tracing? }
- `ConcurrencyConfig` â€” { maxActive: number, maxQueue?: number }
- `EgressConfig` â€” { maxPayloadBytes: number }
- `ToolExposition` â€” 'flat' | 'grouped'
- `IntrospectionConfig<TContext>` â€” { enabled, uri?, filter? }
- `ManifestPayload` â€” { server, mcp_fusion_version, architecture, capabilities: { tools, presenters } }
- `ManifestTool` â€” { description, tags, actions, input_schema }
- `ManifestAction` â€” { description, destructive, idempotent, readOnly, required_fields, returns_presenter }
- `ManifestPresenter` â€” { schema_keys, ui_blocks_supported, has_contextual_rules }
- `PromptResult` â€” { description?: string, messages: PromptMessagePayload[] }
- `PromptMessagePayload` â€” { role: 'user' | 'assistant', content: PromptContentBlock }
- `PromptContentBlock` â€” PromptTextContent | PromptImageContent | PromptAudioContent | PromptResourceContent
- `PromptBuilder<TContext>` â€” DIP interface: .name, .getDefinition(), .handleGet(), .tags
- `PromptConfig<TContext>` â€” { title?, description?, args?, tags?, middleware?, hydrationTimeout?, handler }

### Governance (from '@vinkius-core/mcp-fusion/introspection')

8-module governance stack for deterministic contract auditing, behavioral fingerprinting, and CI/CD lockfile gating.

#### Tool Contracts â€” Schema Materialization
- `materializeContract<TContext>(builder, options?)` â†’ ToolContract â€” extracts the complete behavioral surface (schema, entitlements, guardrails, token profile)
- `compileContracts<TContext>(builders)` â†’ ToolContract[] â€” batch materialization for all registered builders
- `ToolContract` â€” { tool, surface, behavior, cognitiveGuardrails, tokenProfile, handlerEntitlements, integrityDigest }
- `ToolSurface` â€” { actions: ActionContract[], commonFields: string[], discriminator: string }
- `ActionContract` â€” { name, description, destructive, readOnly, idempotent, requiredFields, optionalFields, presenterName? }
- `ToolBehavior` â€” { hasMiddleware, middlewareCount, hasConcurrencyLimit, concurrencyConfig?, hasEgressGuard, egressMaxBytes?, tags, annotations }
- `CognitiveGuardrailsContract` â€” { hasAgentLimit, agentLimitMax?, hasSystemRules, hasDynamicRules, hasUiBlocks, hasSuggestActions }
- `TokenEconomicsProfile` â€” { estimatedTokens, fieldBreakdown: FieldTokenEstimate[], risk: TokenRisk }
- `HandlerEntitlements` â€” { filesystem, network, subprocess, crypto }

#### Contract Diffing â€” Structural Change Detection
- `diffContracts(before, after)` â†’ ContractDiffResult â€” semantic diff between two contract snapshots
- `formatDiffReport(result)` â†’ string â€” human-readable diff report
- `formatDeltasAsXml(deltas)` â†’ string â€” XML-encoded diff for agent consumption (injection-safe)
- `ContractDelta` â€” { path, severity, category, before?, after?, description }
- `DeltaSeverity` â€” `'BREAKING' | 'RISKY' | 'SAFE' | 'COSMETIC'`
- `DeltaCategory` â€” `'schema' | 'behavior' | 'security' | 'guardrails' | 'performance' | 'entitlements' | 'tool-lifecycle'`

#### Behavioral Fingerprinting â€” SHA-256 Digests
- `computeDigest(contract)` â†’ BehaviorDigestResult â€” deterministic SHA-256 fingerprint of a tool's behavioral surface
- `computeServerDigest(contracts)` â†’ ServerDigest â€” aggregate digest over all tool contracts
- `compareServerDigests(a, b)` â†’ DigestComparison â€” compares two server snapshots for drift detection
- `BehaviorDigestResult` â€” { digest: string, components: DigestComponents }
- `ServerDigest` â€” { digest: string, toolCount: number, contracts: BehaviorDigestResult[] }
- `DigestComparison` â€” { match: boolean, added: string[], removed: string[], changed: string[] }

#### Capability Lockfile â€” Git-Diffable CI Gate
- `generateLockfile(options)` â†’ CapabilityLockfile â€” generates a complete lockfile from registry + prompts
- `serializeLockfile(lockfile)` â†’ string â€” deterministic JSON serialization
- `parseLockfile(content)` â†’ CapabilityLockfile | null â€” safe deserialization
- `checkLockfile(current, stored)` â†’ LockfileCheckResult â€” structural comparison with diff details
- `writeLockfile(lockfile, dir?)` â†’ void â€” writes `mcp-fusion.lock` to disk
- `readLockfile(dir?)` â†’ CapabilityLockfile | null â€” reads lockfile from disk
- `LOCKFILE_NAME` â€” `'mcp-fusion.lock'`
- `CapabilityLockfile` â€” { version, generatedAt, serverDigest, capabilities: LockfileCapabilities }
- `LockfileCapabilities` â€” { tools: LockfileTool[], prompts: LockfilePrompt[] }
- `LockfileTool` â€” { name, surface: LockfileToolSurface, behavior: LockfileToolBehavior, tokenEconomics: LockfileTokenEconomics, entitlements: LockfileEntitlements }
- `LockfileCheckResult` â€” { upToDate: boolean, differences: string[], newDigest: string, storedDigest: string }

#### Zero-Trust Runtime â€” Cryptographic Attestation
- `createHmacSigner(secret)` â†’ AttestationSigner â€” HMAC-SHA-256 signer for server digests
- `attestServerDigest(digest, signer)` â†’ AttestationResult â€” sign a digest with timestamp and nonce
- `verifyAttestation(result, signer)` â†’ boolean â€” verify attestation signature
- `verifyCapabilityPin(attestation, knownDigest)` â†’ boolean â€” verify against a pinned digest
- `buildTrustCapability(attestation)` â†’ FusionTrustCapability â€” MCP capability payload for trust negotiation
- `AttestationError` â€” thrown on verification failures
- `ZeroTrustConfig` â€” { signer, digest, attestation }
- `AttestationResult` â€” { digest, signature, timestamp, nonce }

#### Token Economics â€” Cost Profiling
- `estimateTokens(text)` â†’ number â€” approximate token count (GPT-4 heuristic: chars/4)
- `profileBlock(block)` â†’ BlockTokenProfile â€” token profile for a single response block
- `profileResponse(response, config?)` â†’ TokenAnalysis â€” full response token analysis
- `computeStaticProfile(contract)` â†’ StaticTokenProfile â€” static token estimate from contract schema
- `aggregateProfiles(profiles)` â†’ ServerTokenSummary â€” server-wide token economics summary
- `TokenAnalysis` â€” { estimatedTokens, fieldBreakdown, risk, blocks }
- `TokenRisk` â€” `'low' | 'medium' | 'high' | 'critical'`

#### Entitlement Scanner â€” Blast Radius Analysis
- `scanSource(source)` â†’ EntitlementMatch[] â€” static analysis of handler source for capability usage (fs, net, subprocess, crypto)
- `buildEntitlements(matches)` â†’ HandlerEntitlements â€” aggregate matches into entitlement categories
- `validateClaims(report, claims)` â†’ EntitlementViolation[] â€” verify declared entitlements match actual usage
- `scanAndValidate(source, claims)` â†’ { report, violations } â€” combined scan + validate
- `EntitlementCategory` â€” `'filesystem' | 'network' | 'subprocess' | 'crypto'`

#### Semantic Probing â€” LLM-as-Judge Drift Detection
- `createProbe(config)` â†’ SemanticProbe â€” creates a semantic probe for contract comparison via LLM
- `buildJudgePrompt(probe)` â†’ string â€” generates the LLM judge prompt
- `parseJudgeResponse(response)` â†’ SemanticProbeResult â€” parses the judge's response
- `evaluateProbe(probe, adapter)` â†’ SemanticProbeResult â€” end-to-end probe evaluation
- `evaluateProbes(probes, adapter)` â†’ SemanticProbeReport â€” batch evaluation with aggregate scoring
- `aggregateResults(results)` â†’ SemanticProbeReport â€” aggregate probe results
- `DriftLevel` â€” `'none' | 'low' | 'medium' | 'high'`

#### Contract-Aware Self-Healing
- `enrichValidationError(error, contract)` â†’ SelfHealingResult â€” enriches validation errors with contract context for agent self-correction
- `createToolEnhancer(contracts)` â†’ function â€” creates a contract-aware error enhancer for the pipeline

### CLI â€” `fusion lock`
- `fusion lock [--server <entrypoint>] [--name <serverName>]` â€” generate or update `mcp-fusion.lock`
- `fusion lock --check [--server <entrypoint>]` â€” verify lockfile matches current server (CI gate, exits 0 or 1)
- Progress output with timing per step (Composer/Yarn-style status icons)
- Auto-discovers registry + prompts from server entrypoint via ESM dynamic import

### Testing (from '@vinkius-core/mcp-fusion-testing')
- `createFusionTester<TContext>(registry, options)` â†’ FusionTester â€” in-memory MVA lifecycle emulator
- `FusionTester<TContext>` â€” .callAction(toolName, actionName, args?, overrideContext?) â†’ Promise<MvaTestResult>
- `TesterOptions<TContext>` â€” { contextFactory: () => TContext | Promise<TContext> }
- `MvaTestResult<TData>` â€” { data: TData, systemRules: readonly string[], uiBlocks: readonly unknown[], isError: boolean, rawResponse: unknown }

The FusionTester runs the REAL execution pipeline in RAM (Zod â†’ Middleware â†’ Handler â†’ Presenter â†’ Egress Firewall). Zero tokens consumed. Zero servers. Deterministic â€” same input â†’ same output on every CI run. Uses the Symbol Backdoor (MVA_META_SYMBOL) to extract structured MVA layers from ToolResponse without XML parsing.

```typescript
import { createFusionTester } from '@vinkius-core/mcp-fusion-testing';

const tester = createFusionTester(registry, {
    contextFactory: () => ({ prisma: mockPrisma, tenantId: 't_42', role: 'ADMIN' }),
});

// Egress Firewall â€” PII physically absent
const result = await tester.callAction('db_user', 'find_many', { take: 5 });
expect(result.data[0]).not.toHaveProperty('passwordHash');  // SOC2 CC6.1
expect(result.systemRules).toContain('Email addresses are PII.');

// Middleware â€” GUEST blocked
const denied = await tester.callAction('db_user', 'find_many', { take: 5 }, { role: 'GUEST' });
expect(denied.isError).toBe(true);  // SOC2 CC6.3

// OOM Guard â€” Zod rejects
const oom = await tester.callAction('db_user', 'find_many', { take: 99999 });
expect(oom.isError).toBe(true);

// Symbol Invisibility â€” transport never sees metadata
expect(JSON.stringify(result.rawResponse)).not.toContain('passwordHash');
```

### AWS Connector (from 'mcp-fusion-aws')

Auto-discover AWS Lambda functions and Step Functions via resource tags and expose them as grouped MCP tools. Tag filtering controls what the AI can see.

- `createLambdaAdapter(client)` â†’ LambdaAdapter â€” wraps `@aws-sdk/client-lambda` (dynamic import)
- `createSfnAdapter(client)` â†’ SfnAdapter â€” wraps `@aws-sdk/client-sfn` (dynamic import)
- `AwsClient(lambdaAdapter?, sfnAdapter?)` â€” facade over both adapters
  - `.listLambdaFunctions()` â†’ LambdaFunctionSummary[]
  - `.getLambdaTags(arn)` â†’ Record<string, string>
  - `.invokeLambda(arn, payload)` â†’ { statusCode, payload, functionError? }
  - `.listStateMachines()` â†’ SfnStateMachineSummary[]
  - `.getStateMachineTags(arn)` â†’ Record<string, string>
  - `.describeStateMachine(arn)` â†’ { description, type }
  - `.startSyncExecution(arn, input)` â†’ { status, output, error?, cause?, executionArn }
  - `.startExecution(arn, input)` â†’ { executionArn, startDate }
- `LambdaDiscovery(client, options?)` â€” discovers tagged Lambda functions
  - `.discover()` â†’ AwsLambdaConfig[] â€” fetches functions with `mcp:expose=true`
  - `LambdaDiscoveryOptions` â€” { tagFilter?: Record<string, string> }
- `StepFunctionDiscovery(client)` â€” discovers tagged Step Functions
  - `.discover()` â†’ AwsStepFunctionConfig[] â€” fetches state machines with `mcp:expose=true`
- `synthesizeLambdaTools(configs, client)` â†’ SynthesizedToolConfig[] â€” converts discovered Lambdas into tool definitions
- `synthesizeStepFunctionTools(configs, client)` â†’ SynthesizedToolConfig[] â€” converts discovered SFNs into tool definitions
- `synthesizeAll(lambdas, sfns, client)` â†’ SynthesizedToolConfig[] â€” combines both
- `toToolName(name)` â†’ string â€” converts PascalCase/camelCase to snake_case MCP tool name
- `createAwsConnector(config)` â†’ AwsConnector â€” full auto-discovery lifecycle
  - `.tools()` â†’ SynthesizedToolConfig[] â€” current compiled tool definitions
  - `.lambdas` â†’ AwsLambdaConfig[] â€” discovered Lambda configurations
  - `.stepFunctions` â†’ AwsStepFunctionConfig[] â€” discovered Step Function configurations
  - `.client` â†’ AwsClient â€” for use with `defineAwsTool()`
  - `.refresh()` â†’ Promise<boolean> â€” manual poll; returns true if list changed
  - `.stop()` â†’ void â€” stop background polling
  - config: { lambdaClient?, sfnClient?, enableLambda?, enableStepFunctions?, tagFilter?, pollInterval?, onChange?, onError? }
- `defineAwsTool(name, client, config)` â†’ SynthesizedToolConfig â€” manual tool definition
  - config: { arn, description?, annotations?: { readOnlyHint?, destructiveHint? } }
  - ARN detection: `arn:aws:lambda:...` â†’ Lambda invoke, `arn:aws:states:...` â†’ SFN startSyncExecution

Resource Tagging Convention:
- `mcp:expose = true` â€” opt-in, resource becomes an MCP tool
- `mcp:group = <name>` â€” groups multiple resources into a single multi-action tool
- `mcp:action = <name>` â€” action name within a group (default: `execute`)
- `mcp:readOnly = true` â€” marks the action as read-only
- `mcp:destructive = true` â€” marks the action as destructive
- `mcp:sfn-type = express|standard` â€” overrides Step Function execution type

Step Function Execution Types:
- EXPRESS â€” synchronous, blocks until completion, returns parsed output
- STANDARD â€” async fire-and-forget, returns executionArn + cognitive instruction (`_instruction: "Do NOT assume completion"`)

Peer dependencies: `@vinkius-core/mcp-fusion`, `@aws-sdk/client-lambda` (optional), `@aws-sdk/client-sfn` (optional).

```typescript
import { createAwsConnector, createLambdaAdapter, defineAwsTool } from 'mcp-fusion-aws';
import { LambdaClient } from '@aws-sdk/client-lambda';
import { defineTool, ToolRegistry } from '@vinkius-core/mcp-fusion';

const connector = await createAwsConnector({
  lambdaClient: await createLambdaAdapter(new LambdaClient({ region: 'us-east-1' })),
  enableLambda: true,
  pollInterval: 60_000,
  onChange: () => server.notification({ method: 'notifications/tools/list_changed' }),
});

const registry = new ToolRegistry();
for (const tool of connector.tools()) {
  registry.register(defineTool(tool.name, tool.config));
}
```

### OAuth â€” Device Authorization Grant (from '@vinkius-core/mcp-fusion-oauth')

OAuth 2.0 Device Authorization Grant (RFC 8628) for MCP servers. Provider agnostic.

- `DeviceAuthenticator` â€” RFC 8628 Device Flow handshake
  - `.requestDeviceCode(request)` â†’ DeviceCodeResponse (device_code, user_code, verification_uri, verification_uri_complete, expires_in, interval)
  - `.pollForToken(codeResponse, signal?)` â†’ TokenResponse (polls with slow_down respect + AbortSignal support)
  - `.attemptTokenExchange(request)` â†’ TokenResponse (single exchange attempt for manual polling)
- `TokenManager` â€” Secure file-based token storage (0o600 permissions, env-var priority)
  - `.getToken()` â†’ string | null (env var > file)
  - `.getTokenSource()` â†’ 'environment' | 'file' | null
  - `.saveToken(token)` â†’ void (saves to ~/.{configDir}/token.json)
  - `.clearToken()` â†’ void
  - `.savePendingDeviceCode(code, ttl)` â†’ void (survives process restarts)
  - `.getPendingDeviceCode()` â†’ DeviceCodeResponse | null (auto-expired)
- `createAuthTool<TContext>(config)` â†’ GroupedToolBuilder with 4 actions: login, complete, status, logout
  - config: { clientId, authorizationEndpoint, tokenEndpoint, headers?, tokenManager, onAuthenticated, onLogout?, getUser? }
- `requireAuth(options?)` â†’ MiddlewareFn â€” rejects unauthenticated requests with toolError('AUTH_REQUIRED') + recovery hints
  - options: { extractToken: (ctx) => string | null, recoveryHint?, recoveryAction? }
- Types: DeviceAuthenticatorConfig, DeviceCodeRequest, DeviceCodeResponse, TokenRequest, TokenResponse, DeviceFlowError, TokenManagerConfig, StoredToken, TokenSource, AuthToolConfig, AuthContext, RequireAuthOptions

```typescript
import { createAuthTool, requireAuth } from '@vinkius-core/mcp-fusion-oauth';

const auth = createAuthTool({
    clientId: 'your-client-id',
    authorizationEndpoint: 'https://api.example.com/oauth/device/code',
    tokenEndpoint: 'https://api.example.com/oauth/device/token',
    tokenManager: { configDir: '.myapp', envVar: 'MY_APP_TOKEN' },
    onAuthenticated: (token, ctx) => ctx.setToken(token),
    getUser: async (ctx) => ctx.getMe(),
});
```

### Cloudflare Workers Adapter (from '@vinkius-core/mcp-fusion-cloudflare')

Deploy MCP Fusion servers to Cloudflare Workers edge. Stateless JSON-RPC â€” no SSE sessions, no streaming state. Registry compiles at cold start (Zod reflection, Presenter compilation cached). Warm requests only instantiate McpServer + Transport. Uses the MCP SDK's native `WebStandardStreamableHTTPServerTransport` with `enableJsonResponse: true`.

- `cloudflareWorkersAdapter<TEnv, TContext>(options)` â†’ CloudflareWorkerHandler â€” creates a Workers `fetch()` handler
  - options: { registry, serverName?, serverVersion?, contextFactory?, attachOptions? }
  - `registry` â€” pre-compiled ToolRegistry (built at module scope, cached across warm requests)
  - `contextFactory(req, env, ctx)` â€” creates per-request context from Cloudflare bindings (D1, KV, R2, secrets, ExecutionContext)
  - `serverName` â€” MCP server name (default: `'mcp-fusion-edge'`)
  - `serverVersion` â€” version string (default: `'1.0.0'`)
  - `attachOptions` â€” forwarded to `registry.attachToServer()` (filter, stateSync, debug, etc.)
- `CloudflareWorkerHandler<TEnv>` â€” { fetch(request, env, ctx): Promise<Response> }
- `CloudflareAdapterOptions<TEnv, TContext>` â€” full configuration interface
- `RegistryLike` â€” duck-typed interface (any object with `attachToServer()`)
- `ExecutionContext` â€” inline Cloudflare Workers types (waitUntil, passThroughOnException)

Peer dependencies: `@vinkius-core/mcp-fusion` (^2.0.0), `@modelcontextprotocol/sdk` (^1.12.0).

```typescript
import { initFusion } from '@vinkius-core/mcp-fusion';
import { cloudflareWorkersAdapter } from '@vinkius-core/mcp-fusion-cloudflare';
import { z } from 'zod';

interface AppContext { db: D1Database; tenantId: string }
const f = initFusion<AppContext>();

const listUsers = f.tool({
  name: 'users.list',
  input: z.object({ limit: z.number().optional().default(20) }),
  readOnly: true,
  handler: async ({ input, ctx }) =>
    ctx.db.prepare('SELECT id, name FROM users LIMIT ?').bind(input.limit).all(),
});

const registry = f.registry();
registry.register(listUsers);

export interface Env { DB: D1Database }

export default cloudflareWorkersAdapter<Env, AppContext>({
  registry,
  contextFactory: async (req, env) => ({
    db: env.DB,
    tenantId: req.headers.get('x-tenant-id') || 'public',
  }),
});
```

### Domain Models
- `BaseModel` â€” abstract base (name, title, description, meta, icons)
- `GroupItem` â€” leaf with multi-parent groups
- `Group` â€” tree node (addChildGroup, addChildTool, addChildPrompt, addChildResource)
- `Tool` â€” inputSchema, outputSchema, toolAnnotations
- `Resource` â€” uri, size, mimeType, annotations
- `Prompt` â€” promptArguments
- `PromptArgument` â€” required: boolean
