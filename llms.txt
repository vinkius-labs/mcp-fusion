# mcp-fusion

> The MVA (Model-View-Agent) framework for building MCP servers where AI agents are first-class consumers.

## What is mcp-fusion?

mcp-fusion is a TypeScript framework for the Model Context Protocol (MCP) that introduces the **MVA (Model-View-Agent)** architectural pattern — created by Renato Marinho at Vinkius Labs. Instead of dumping raw JSON and hoping the AI figures it out, MVA adds a **Presenter** (the View layer) that gives every response structure: validated data, domain rules, rendered charts, action affordances, and cognitive guardrails.

## Core Architecture: MVA (Model-View-Agent)

```
Model (Zod Schema) → View (Presenter) → Agent (LLM)
   validates            perceives          acts
```

The Presenter replaces the human-centric View with an agent-centric perception layer. Every tool response becomes a **structured perception package** — not raw JSON.

## Core Concepts

- **MVA Pattern**: Model-View-Agent — the architectural foundation where Presenters replace Views
- **Presenter**: Domain-level View layer — schema validation, system rules, UI blocks, affordances, guardrails
- **GroupedToolBuilder**: Fluent builder that groups related actions into a single MCP tool
- **createTool()**: Factory function to create a GroupedToolBuilder with full Zod power
- **defineTool()**: JSON-first factory — define tools without Zod imports using plain strings/objects
- **createPresenter()**: Fluent builder for domain-level Presenters
- **ResponseBuilder**: Fine-grained manual response composition
- **Action**: A single operation within a grouped tool (e.g., "list", "create", "delete")
- **Group**: Hierarchical namespace for actions (e.g., "users.create", "billing.refund")
- **Discriminator**: The field name the LLM uses to select the action (default: "action")
- **CommonSchema**: Shared Zod schema injected into every action
- **ToolRegistry**: Centralized registry for all tool builders
- **Middleware**: Pre-compiled middleware chains following the next() pattern
- **Tags**: Capability labels for selective tool exposure per session
- **TOON**: Token-Oriented Object Notation for compact descriptions/responses
- **State Sync**: RFC 7234-inspired cache-control signals to prevent temporal blindness

## Quick Start — MVA with Presenter

```typescript
import { createPresenter, ui, defineTool, success } from '@vinkius-core/mcp-fusion';
import { z } from 'zod';

// 1. Define the Presenter — the MVA View Layer
export const InvoicePresenter = createPresenter('Invoice')
    .schema(z.object({
        id: z.string(),
        amount_cents: z.number(),
        status: z.enum(['paid', 'pending', 'overdue']),
    }))
    .systemRules(['CRITICAL: amount_cents is in CENTS. Divide by 100.'])
    .uiBlocks((inv) => [
        ui.echarts({ series: [{ type: 'gauge', data: [{ value: inv.amount_cents / 100 }] }] }),
    ])
    .suggestActions((inv) =>
        inv.status === 'pending'
            ? [{ tool: 'billing.pay', reason: 'Process payment' }]
            : []
    );

// 2. Attach to any tool — handler returns raw data, Presenter does the rest
const billing = defineTool<AppContext>('billing', {
    actions: {
        get_invoice: {
            returns: InvoicePresenter,
            params: { id: 'string' },
            handler: async (ctx, args) => await ctx.db.invoices.findUnique(args.id),
        },
    },
});

const registry = new ToolRegistry<AppContext>();
registry.register(billing);
registry.attachToServer(server, {
    contextFactory: (extra) => createAppContext(extra),
});
```

## Quick Start — defineTool() (No Zod Required)

```typescript
import { defineTool, ToolRegistry, success, error } from '@vinkius-core/mcp-fusion';

const projects = defineTool<AppContext>('projects', {
    description: 'Manage workspace projects',
    shared: { workspace_id: 'string' },
    actions: {
        list: {
            readOnly: true,
            params: { status: { enum: ['active', 'archived'] as const, optional: true } },
            handler: async (ctx, args) => success(await ctx.db.projects.findMany()),
        },
        create: {
            params: {
                name: { type: 'string', min: 1, max: 100 },
                email: { type: 'string', regex: '^[\\w-.]+@([\\w-]+\\.)+[\\w-]{2,4}$' },
            },
            handler: async (ctx, args) => success(await ctx.db.projects.create(args)),
        },
        delete: {
            destructive: true,
            params: { project_id: 'string' },
            handler: async (ctx, args) => {
                await ctx.db.projects.delete(args.project_id);
                return success('Project deleted');
            },
        },
    },
});
```

## Quick Start — createTool() (Full Zod Power)

```typescript
import { createTool, ToolRegistry, success, error } from '@vinkius-core/mcp-fusion';
import { z } from 'zod';

const projects = createTool<AppContext>('projects')
    .description('Manage workspace projects')
    .commonSchema(z.object({
        workspace_id: z.string().describe('Workspace identifier'),
    }))
    .action({
        name: 'list',
        readOnly: true,
        schema: z.object({ status: z.enum(['active', 'archived']).optional() }),
        handler: async (ctx, args) => success(await ctx.db.projects.findMany({ where: args })),
    })
    .action({
        name: 'create',
        schema: z.object({ name: z.string() }),
        handler: async (ctx, args) => success(await ctx.db.projects.create({ data: args })),
    })
    .action({
        name: 'delete',
        destructive: true,
        schema: z.object({ project_id: z.string() }),
        handler: async (ctx, args) => {
            await ctx.db.projects.delete({ where: { id: args.project_id } });
            return success('Deleted');
        },
    });
```

## Presenter API

```typescript
import { createPresenter, ui } from '@vinkius-core/mcp-fusion';

const UserPresenter = createPresenter('User')
    .schema(z.object({ id: z.string(), name: z.string(), role: z.string() }))
    .systemRules(['Display name in bold'])
    .systemRules((user, ctx) => ctx.isAdmin ? ['Show internal fields'] : ['Hide internal fields'])
    .uiBlocks((user) => [ui.summary({ total: 1, showing: 1 })])
    .agentLimit(50, { warningMessage: 'Showing {shown} of {total}. Use filters.' })
    .suggestActions((user) => [
        { tool: 'users.update', reason: 'Edit this user', args: { id: user.id } },
    ])
    .embed('team', TeamPresenter);
```

## Presenter Composition

```typescript
const OrderPresenter = createPresenter('Order')
    .schema(OrderSchema)
    .embed('customer', CustomerPresenter)
    .embed('items', LineItemPresenter);
// Child Presenters' rules, UI blocks, and suggestions are automatically merged.
```

## ResponseBuilder (Manual Composition)

```typescript
import { ResponseBuilder } from '@vinkius-core/mcp-fusion';

const response = ResponseBuilder.create(data)
    .systemRules(['Format currency in USD'])
    .uiBlock(ui.echarts({ /* chart config */ }))
    .llmHint('This invoice is overdue')
    .suggestActions([{ tool: 'billing.pay', reason: 'Pay now' }])
    .build();
```

## DX Shortcuts

```typescript
import { response, ui } from '@vinkius-core/mcp-fusion';

return response.ok(data);                          // Simple success
return response.withRules(data, ['Rule 1']);        // Data + rules
ui.echarts({ series: [...] });                     // ECharts chart
ui.mermaid('graph TD; A-->B');                      // Mermaid diagram
ui.summary({ total: 100, showing: 10 });           // Collection summary
```

## Hierarchical Groups

```typescript
const platform = createTool<AppContext>('platform')
    .tags('core')
    .group('users', 'User management', g => {
        g.use(requireAdmin)
         .action({ name: 'list', readOnly: true, handler: listUsers })
         .action({ name: 'ban', destructive: true, schema: banSchema, handler: banUser });
    })
    .group('billing', 'Billing operations', g => {
        g.action({ name: 'refund', destructive: true, schema: refundSchema, handler: issueRefund });
    });
// Discriminator values: "users.list" | "users.ban" | "billing.refund"
```

## Middleware

```typescript
const requireAuth: MiddlewareFn<AppContext> = async (ctx, args, next) => {
    if (!ctx.user) return error('Unauthorized');
    return next();
};

// tRPC-style context derivation
const withDb = defineMiddleware(async (ctx) => ({
    ...ctx,
    db: await createDbConnection(ctx.tenantId),
}));

createTool<AppContext>('projects')
    .use(requireAuth)
    .use(withDb)
    .action({ name: 'list', handler: async (ctx, args) => success(await ctx.db.query()) });
```

## Self-Healing Errors

```typescript
import { toolError } from '@vinkius-core/mcp-fusion';

return toolError('INVALID_DATE_RANGE', {
    message: 'Start date must be before end date',
    recovery: { action: 'retry', suggestion: 'Swap the date values' },
    suggestedArgs: { start: args.end, end: args.start },
});
```

## State Sync

```typescript
import { cacheSignal, invalidates } from '@vinkius-core/mcp-fusion';

// Read action — tell the agent how long data is fresh
handler: async (ctx, args) => cacheSignal(data, { maxAge: 30, scope: 'invoices' });

// Write action — tell the agent what data is now stale
handler: async (ctx, args) => invalidates(result, ['invoices', 'billing']);
```

## Tag Filtering

```typescript
registry.attachToServer(server, { filter: { tags: ['core'] } });      // Only core tools
registry.attachToServer(server, { filter: { exclude: ['internal'] } }); // No internal tools
```

## Response Helpers

```typescript
import { success, error, required, toonSuccess, toolError } from '@vinkius-core/mcp-fusion';

return success('Task completed');
return success({ id: '123', name: 'Acme' });
return error('Project not found');
return required('workspace_id');
return toonSuccess(users);                  // ~40% fewer tokens
return toolError('NOT_FOUND', { message: 'Invoice not found', recovery: { action: 'list' } });
```

## Streaming Progress

```typescript
handler: async function* (ctx, args) {
    yield progress(0.25, 'Loading data...');
    const data = await ctx.db.query();
    yield progress(0.75, 'Processing...');
    return success(data);
}
```

## Important Rules

1. `.action()` and `.group()` are MUTUALLY EXCLUSIVE on the same builder
2. Action names must NOT contain dots (dots are reserved for group.action keys)
3. After `buildToolDefinition()`, the builder is FROZEN — no more modifications
4. `execute()` auto-calls `buildToolDefinition()` if not already called
5. `commonSchema` fields are marked `(always required)` in auto-generated descriptions
6. Zod `.merge().strip()` is used at runtime — unknown fields are silently stripped
7. Middleware chains are pre-compiled at build time — zero runtime allocation
8. Tool names must be unique across a ToolRegistry
9. Presenters are immutable after creation — define once, reuse across tools
10. `.agentLimit()` automatically truncates and injects guidance blocks

## Public API (all from '@vinkius-core/mcp-fusion')

### Builder
- `createTool<TContext>(name)` → GroupedToolBuilder (fluent builder, requires Zod)
- `defineTool<TContext>(name, config)` → GroupedToolBuilder (JSON-first, no Zod required)
- `GroupedToolBuilder<TContext>` — .description(), .commonSchema(), .discriminator(), .tags(), .annotations(), .toonDescription(), .use(), .action(), .group(), .buildToolDefinition(), .execute(), .previewPrompt(), .getName(), .getTags(), .getActionNames(), .getActionMetadata()
- `ActionGroupBuilder<TContext>` — .use(), .action()

### Presenter (MVA View Layer)
- `createPresenter(name)` → PresenterBuilder — .schema(), .systemRules(), .uiBlocks(), .agentLimit(), .suggestActions(), .embed()
- `ResponseBuilder.create(data)` → ResponseBuilder — .systemRules(), .uiBlock(), .llmHint(), .suggestActions(), .build()
- `ui.echarts(config)` → UIBlock (ECharts chart)
- `ui.mermaid(code)` → UIBlock (Mermaid diagram)
- `ui.summary(stats)` → UIBlock (Collection summary)
- `response.ok(data)` → ToolResponse (success shortcut)
- `response.withRules(data, rules)` → ToolResponse (data + system rules)

### Registry
- `ToolRegistry<TContext>` — .register(), .registerAll(), .getAllTools(), .getTools(filter), .routeCall(), .attachToServer(), .has(), .clear(), .size

### FusionClient (tRPC-style)
- `createFusionClient<TRouter>(transport)` → FusionClient — type-safe client with autocomplete
- `FusionClient<TRouter>` — .execute(action, args) with full type inference

### Response Helpers
- `success(data)` → ToolResponse
- `error(message)` → ToolResponse (isError: true)
- `required(field)` → ToolResponse (isError: true)
- `toolError(code, options)` → ToolResponse (structured recovery hints for LLM agents)
- `toonSuccess(data, options?)` → ToolResponse (TOON-encoded)

### State Sync
- `cacheSignal(data, options)` → ToolResponse with cache-control metadata
- `invalidates(data, scopes)` → ToolResponse with invalidation signals

### Streaming Progress
- `progress(percent, message)` → ProgressEvent (yield from generator handlers)
- `isProgressEvent(value)` → type guard

### Result Monad
- `succeed<T>(value)` → Success<T>
- `fail(response)` → Failure
- `Result<T>` = Success<T> | Failure

### Middleware
- `defineMiddleware(deriveFn)` → MiddlewareDefinition (tRPC-style context derivation)
- `resolveMiddleware(input)` → MiddlewareFn

### Observability
- `createDebugObserver(options?)` → Observer for runtime debugging
- Event types: tool:start, tool:end, tool:error, middleware:start, middleware:end

### Types
- `ToolResponse` — { content: [{ type: "text", text: string }], isError?: boolean }
- `MiddlewareFn<TContext>` — (ctx, args, next) => Promise<ToolResponse>
- `ActionConfig<TContext>` — { name, description?, schema?, destructive?, readOnly?, handler, returns? }
- `PresenterConfig` — { schema, systemRules?, uiBlocks?, agentLimit?, suggestActions?, embeds? }
- `ToolBuilder<TContext>` — Interface for custom builders
- `ActionMetadata` — { key, actionName, groupName, description, destructive, idempotent, readOnly, requiredFields, hasMiddleware }
- `ToolFilter` — { tags?: string[], exclude?: string[] }
- `AttachOptions<TContext>` — { contextFactory?, filter? }

### Domain Models
- `BaseModel` — abstract base (name, title, description, meta, icons)
- `GroupItem` — leaf with multi-parent groups
- `Group` — tree node (addChildGroup, addChildTool, addChildPrompt, addChildResource)
- `Tool` — inputSchema, outputSchema, toolAnnotations
- `Resource` — uri, size, mimeType, annotations
- `Prompt` — promptArguments
- `PromptArgument` — required: boolean
